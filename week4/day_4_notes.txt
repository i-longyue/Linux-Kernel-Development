第8章  下半部和推后执行的工作
	在第7章我们讨论了内核为处理中断而提供的中断处理机制.
	中断处理程序是内核中很有用的部分.但是,由于本身存在一些局限,所以它只能完成整个中断
	处理流程的上半部分.这些局限包括:

	*中断处理程序以异步方式执行,并且它有可能会打断其他重要代码(甚至包括其他中断处理程序)
	的执行.因此,为了避免被打断的代码停止时间过长,中断处理程序应该执行得快好.

	*如果当前有一个中断处理程序正在执行,在最好的情况下(如果IRQF_DIABLED)设有被设置,与该
	中断同级的其他中断会被屏蔽,在最坏的情况下(如果设置了IRQF_DISABLED),当前处理器上所有
	的其他中断都会被屏蔽.因为禁止中断后硬件与操作系统无法通信,因此,中断处理器上所有地
	其他中断都会被屏蔽.因为禁止中断后硬件与操作系统无法通信

	*中断处理程序不在进程上下文中运行,所以它们不能为阻塞.这限制了它们所做的事情.

	现在为什么中断处理程序只能作为整个硬件中断处理流程的一部分的原因就很明显了.
	操作系统必须有一个快速,异步,简单的机制负责对硬件做出迅速响应并完成那些时间
	要求很严格的操作.中断处理程序很适合于实现这些功能,可是,对于那些其他的,对时间要求相对
	宽松的任务,就应该推后到中断被激活以后再去运行.

	这样,整个中断处理流程被分为了两个部分,或叫两半.第一个部分是中断处理程序,内核通过对它的异步
	执行完成对硬件中断的即时响应.在本章中,我们要研究的是中断处理流程的另外一部分,下半部.

8.1 下半部
	下半部的任务就是执行与中断处理程序相关但中断处理程序本身不执行的工作.
	在理想情况下,最好是中断处理程序将所有地的工作都交给下半部分执行,因为我们希望在中断中处理的
	时间可能快的返回.

	但是,中断处理程序注定要完成一部分工作,例如,中断处理程序几乎都需要通过操作硬件对中断的到达
	进行确认,有时它还会从硬件拷贝数据.因为这些工作对时间敏感,所以只能靠中断处理程序去完成.

	剩下的几乎所有其他工作都是下半部执行的目标.例如,如果你在上半部中把数据从硬件拷贝到了内存,
	那么当然应该在下半部中处理它们.并不存在严格明确的规定来说明到底什么任务应该在哪个部分中完成
	对于在上半部分和下半部分之间划分工作,尽管不存在某种严格的规则,但是还是有一些提示可供借鉴:
		*如果一个任务对时间非常敏感,将其放在中断处理程序中执行.
		*如果一个任务和硬件相关,将其放在中断处理程序中断执行
		*如果一个任务要保证不被其他中断(特别是相同的中断)打断,将其放在中断处理程序中断,将其
		放在中断处理程序中执行.
		*当他所有任务,考虑放置在下半部执行.


8.1.1 为什么要用下半部
	理解为什么要让工作推后执行以及在什么时候推后执行非常关键.我们必须尽力缩短中断处理程序的执行.
	解决的方法就是把一些工作放到以后去做.
	但具体放到以后什么时候去做呢?在这里,以后仅仅来强调不是马上而已.
	不仅是Linux,许多操作系统也把处理硬件中断过程分为两个部分.上半部分简单快速,执行的时候禁止
	一些或者全部中断.


8.1.2 下半部分的环境
	和上半部分只能通过中断处理程序实现不同,下半部分可以通过多种机制实现.这些用来实现下半部
	的机制分别由不同的接口和子系统组成.在第7章中,我们了解到实现中断处理程序的方法只有一种,
	实现下半部分会有许多不同的方法.
	实际上,在Linux发民过程中曾出现过多种下半部机制
	在本意中,我们将要讨论2.6版本的内核中的下半部机制是如何设计实现的.同时我们也会讨论怎么在
	自己编写的内核代码中使用它们.



	1."下半部"的起源
	最早的Linux只提供"bottom half"这种机制用于实现下半部.这个名字在那里毫无异义,因为当时它是
	将工作推后的唯一方法.这种机制也被称为"BH",我们现在也这么叫它,
	BH接口,它提供了一个静态创建,由32个bottom halves组成的链表.上半部通过一个32位整数中的一位
	来标识出哪个bottom half可以执行.每个BH都在全局范围内进行同步,即使分属于不同的处理器,也不
	允许任何两个bottom half同时执行.这种机制使用方便却不够灵活,简单却有性能瓶颈.

	2.任务队列
	不久,内核开发者们就引入了任务队列机制来实现工作的推后执行,并用它来代替BH机制.
	内核为此定义一组队列,其中每个队列都包含一个由等待调用的函数组成链表.根据其所处
	队列的位置,这些函数会在某个时执行.驱动程序可以把它们自己的下半部注册到合适的队列上去.
	但仍不够灵活,没法代替整个BH接口,对于一些性能要求高的子系统,它不能能任.


	3.软中断和tasklet
	在2.3这个开发版本中,内核开发者引入了软中断(softirqs)和tasklet
	如果无需考虑和过支开发的驱动程序兼容,

	*软中断是一组静态定义的下半部接口,有32个,可以在所有处理器上同时执行---即使两个类型相同
	也可以.tasklet这一名称起得很,它们是一种基于软中断实现的灵活性强,动态创建的下半部实现
	机制.两个不同类型的tasklet可以在不同处理器上同时执行,但类型相同的tasklet不能同时执行
	tasklet其实是一种在性能和易用性之间寻求平衡的产物.对于大部分下半部分处理来说,
	tasklet就足够了,像网络这样的软中断有可能同时被执行.此外,软中断还必须在编译期间就进行
	静态注册.与次相反,tasklet可以通过代码进行动态注册.

		有些人被这些概念彻底搞糊涂了,他们把所有的下半部都当成是软件产生的中断或软中断.
		换名话说,就是他们把软件中断机制和下半部统统叫软中断.别管他们好了.软中断与BH和
		tasklet并驾其名.
	
	在开发2.5版本内核的时,BH接口最终被弃置了,所有的BH使用者必须转而使用其他
	下半部接口.此外,任务队列接口也被工作队列接口取代了.工作队列是一种简单但很有用的方法
	它们先对要推后执行的工作排队,稍后在进程上下文中执行它们,稍后的内容中我们再来探究它
	们.

	在2.6这个版本中,内核提供了三种不同形式的下半部实现机制:软中断,tasklets和工作队列.
	内核过去曾经用过的BH和任务队列接口.


	内核定时器
		另外一个可以用于将工作推后执行的机制是内核定时器.不像本章到目前为止介绍到的所有
		这些机制,内核定时器把操作推后到除了现在以外的任何时间进行,但是当你必须保证一个
		确定的时间段过去以后再运行时,你应该使用内核定时器.

	较之本章讨论到的这些机制,定时器还有一些其他功能.有关定时器的详细在第11章中讨论.

	4.混乱的下半部概念
	这些东西确实把人搅得很混乱,但它们其实只不过是一些起名的问题,让我们再来梳理一遍.
	下半部是一个操作系统通用词汇,用于指代中断处理流程中推后执行的那一部分,之所以这样
	命名,是因为它表示中断处理方案一半的第二部分或下半部分.在Linux中,这个词目前确实
	就是这个含义.所有用于实现将工作推后执行的内核机制都被称为"下半部机制".

	一些人错误地把所有的下半部机制都叫做"软中断",真是在自寻烦恼.
    "下半部"这个词也指代Linux最早提供的那种将工作推后执行的实现机制.由于该机制也被叫
	做"BH",所以,我们就使用它这个名称,2.5版本内核它就完全去除了.

	当前,有三种机制可以用来实现将工作推后执行:软中断,tasklet和工作队列.tasklet通过
	软中断实现,而工作队列与它们完全不同.




8.2 软中断
	我们的讨论从实际的下半部实现----软中断方法开始.软中断使用得比较少;而tasklet是下半
	部更常用的一种形式.但是,由于tasklet是通过软中断实现的,所以我们先来研究软中断.
	软中断的代码位于kernel/softirq.c文件中.

8.2.1 软中断的实现
	软中断是在编译期间静态分配的.它不像tasklet那样能被动态地注册或注销.软中断由
	softirq_action结构表示,它定义在<linux/interrupt.h>中:

	struct softirq_action{
		void (*action)(struct softirq_action *);
	};

	kernel/softirq.c中定义了一个包含有32个该结构体的数组.
	static struct softirq_action softirq_vec[NR_SOFTIRQS]
	每个注册的软中断都占据该组的一项.

	1.软中断处理程序
	软中断处理程序action的函数原型如下:
	void  softirq_hander(struct softirq_action *)

	当内核运行一个软中断处理程序的时候,它就会执行这个action函数,其唯一的
	参数为相应softirq_action结构体的指针.例如,如果my_softirq指向softirq_vec
	数组的某项,那么内核会用如下方式调用软中断处理程序中的函数

	my_softirq->action(my_softirq);
	
	一个软中断不会抢占另外一个软中断.实际上唯一可以抢占中断的是中断处理程序
	不过,其他的软中断可以在其他处理器上同时执行.

	2.执行软中断
	一个注册的软中断必须在被标记后才会被执行.这被称作触发软中断,
	通常中断处理程序会在返回前标记它的软中断,使其在稍后被执行.于是,
	在下列地方,待处理的软中断会被检查和执行.于是,在合适的时间,该中断就会运行.
	在下列地方,待处理的软中断就会被检查和执行:
	*从一个硬件中断代码处返回时
	*在ksoftirqd内核线程中
	*在那些显式检查和执行待处理的软中断的代码中,如网络子系统中

	不管是用什么办法唤起,软中断都要在do_softirq()中执行.该函数很简单.如果有待
	处理的软中断,do_softirq()会循环遍历一个,调用它们的处理程序,让我们观察一下
	do_softirq()经过简化后的核心部分.
		u32 pending;
		pending = local_softirq_pending();
		if(pending){
			struct softirq_action *h;

			/* 重设待处理的位置 */
			set_softirq_pending(0);

			h = softirq_vec;
			do{
				if(pending & 1)
					h->action(h);
				h++;
				pending >>= 1;
			} while(pending);
		}
	以上摘录的是软中断处理的核心部分.它检查并执行所有待处理的软中断,具体要做的包括:
	1)用局部变量pending保存local_softirq_pending()宏的返回值.它是等待处理软中断的32位
	位图----如果第n位被设置为1,那么第n位对应类型的软件中断等待处理.

	2)现在待处理的软中断位图已经被保存,可以将实际的软中断位图清零了.
	3)将指针h指向softirq_vec的第一项.
	4)如果pending的第一位置被置为1,则h->action(h)被调用.
	5)指针加1,所以现在它指向softirq_vec数据的第二项.
	6)位掩码pending右移一位.
	7)现在指针h指向数组的第二项,pending位掩码的第二
	8)一直重复下去,直到pending为0,说明没有待处理的软中断了,我们的任务就完成了.
	

8.2.2 使用软件中断
	软件中断保留给系统中对时间要求最严格以及最重要的下半部使用.目前有两个子系统(网络和SCSI)
	直接使用软中断.此外,内核定时器和tasklet都是建立在软中断上的.如果你想加入一个新的软中断,
	首先总部问自己为什么用tasklet实现不了.tasklet可以动态生成,由于它们对加锁的要求不高,所以
	使用起来方便,而且它们的性能也非常不错.当然,对于时间要示严格并能自己高效地完成加锁工作的
	应用

	1.分配索引
	索引号小的软中断在索引号在的软中断之前执行.

	2.注册你的处理程序
	接着,在运行时通过调用open_softirq()注册软中断处理程序,该函数有两个参数:
	软中断的索引号和处理函数.如网络子系统,在net/coreldev.c通过以下方式注册自己的软中断
	open_softirq(NET_TX_SOFTIRQ, net_tx_action);
	open_softirq(NET_RX_SOFTIRQ, net_rx_action);
	软中断处理程序执行的时候,允许响应中断,但它自己不能休眠.在一个处理程序运行的时候,当前
	处理器上的软中断被禁止,但其他的处理器仍可以同时运行其处理程序.这意味着任何共享数据都
	需要严格的锁保护.


	3.触发你的软中断
	通过在枚举类型的列表中添加新项以及调用open_softirq()进行注册以后,新的软中断处理程序就
	能够运行.raise_softirq()函数可以将一个软中断设置为挂起状态,让它在下次调用do_softirq()
	函数时投入运行.

	raise_softirq(NET_TX_SOFTIRQ);
	这会触发NET_TX_SOFTIRQ软中断.它的处理程序net_tx_action()就会在内核下一次软中断时投
	入运行.这个函数触发一个软中断之前要先禁止中断,触发后再恢复原来的状态.如果中断本来就
	已经被禁止了,那么可以调用另一函数raise_softirq_irqoff()这会带来一些优化效果.



8.3 tasklet
	tasklet是利用中断实现的一种下半部机制.我们之前提到过,它和进程没有任何关系.
	选择到底是软中断还是tasklet其很简单:通常你应该使用tasklet.就像我们在前面看到的,软中断
	使用者.它只在那些执行频率很高和连接性要求很高的情况下才需要使用.而tasklet却有更广泛的
	用途.

8.3.1 tasklet的实现
	因为tasklet是通过软中断实现的,所以它们本身也是软中断.前面讨论过了,tasklet由两类软中断代表:
	HI_SOFTIRQ和TASKLET_SOFTIRQ.这两者之间唯一实际区别在于,HI_SOFTIRQ类型的软中断先于TASKLET_
	SOFTIRQ类型的软中断执行.



1.tasklet结构体
	tasklet由tasklet_struct结构表示.每个结构体单独代表一个tasklet,它在<linux/interrupt.h>
	中定义为:
	struct tasklet_struct{
		strcuct 
			...
	}
	结构体中的func成员是tasklet的处理程序(像软中断中的action一样),data是它唯一的参数
	state成员只能在0,TASKLET_STATE_SCHED和TASKLET_STATE_RUN之间取值.

2.调度tasklet
	已调用的tasklet,存放在两个单独处理器:tasklet_vec和tasklet_hi_vec高优先级,这两个结构
	都是由tasklet_struct结构体构成的链表.链表中的每个tasklet_struct代表一个不同的tasklet

	tasklet_struct结构体构成的链表.链表中的每个tasklet_struct代表一个不同的tasklet
	tasklet由tasklet_schedule()和tasklet_hi_schedule函数进行调度,它们接受一个指向tasklet_struct
	结构指针作为参数.

	tasklet_schedule()的执行步骤:
	1)检查tasklet的状态是否为TASKLET_STATE_SCHED.如果是,说明tasklet已经被调度过了,函数立即返回
	2)调用_tasklet_schedule()
	3)保存中断状态,然后禁止本地中断.在我们执行tasklet代码时,在我们执行tasklet代码时,这么做能够
	保证当tasklet_schedule()处理这些tasklet时,处理器上的数据不会弄乱.
	4)把需要调度的tasklet加到每个处理器一个tasklet_vec链表或tasklet_hi_vec
	5)唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断,这样在下一次调用do_softirq()时就会执行该tasklet
	6)恢复中断到原状态并返回

	在前面的内容中我们曾经提到过挂起来,do_softirq()会尽可能早地在下一个合适的时机执行.
	由于大部分tasklet和软中断都是在中断处理程序中被设置成待处理状态,所以最近一个中断返回
	的时候看起来就是执行do_softirq.因为TASKLET_SOFTIRQ和HI_SOFTIRQ已经被触发了,所以do_softirq
	会执行相应的软中断处理程序.而这两个处理程序,tasklet_action()和tasklet_hi_action(),就是task
	let处理的核心

	1)禁止中断
	2)将当前处理器上的链表设置为NULL
	3)允许响应中断.
	4)循环遍历获得链表上的第一个待处理的tasklet
	5)如果是多处理器系统
	6)如果当前这个tasklet没有执行,将其状态设置为tasklet_state_run,这样别的处理器就不会去执行它了
	7)
	8)
	9)
	10)重复读下一个


8.3.2 使用tasklet
1.声明你自己的tasklet
使用下面<linux/interrupt.h>中定义的两个宏中的一个:
DECLARE_TASKLT(name, func, date)
DECLARE_TASKLT_DISABLED(name, func, data);


2.编写你自己的tasklet处理程序
void tasklet_handler(unsigned long data)
因为靠软中断实现,所以tasklet不能睡眠.

3.调度你自己的tasklet
tasklet_enable()
tasklet_kill()


4.ksoftirqd
	每个处理器都有一组辅助处理软中断(和tasklet)的内核线程.当内核中出现大量软中断的时候,
	这些内核进程就会辅助处理它们.

	在设计软中断时,开发者就意识到需要一些折中.
	最终在内核中实现的方案是不会立即处理重新触发软中断,而作为改进,当大量软中断出现的时候,
	内核会唤醒一组内核线程来处理这些负载.这些地线程在最低的优先级上运行(nice值为19),这能避免
	它们跟其他重要任务抢夺资源.但它们最终肯定会被执行,所以,这个折中方案能够保证在软中断负担
	很生的时候,用户程序不会因为得不到处理时间而处于饥饿状态.相应的过量的软中断终究会得到处理.
	最后,在空闲系统上,这个方案同样表现良好
	
	每个处理器都有一个这样的线程,所有线程的名字都叫做ksoftirqd/n,区别在于n
	为了保证只要有空闲的处理器,它们就会处理软中断,所以给每个处理器都分配一个这样的线程
	

	一旦该线程被初始化,它就会执行类似下面这样的死循环:
	for(;;){
		if(!softirq_pneding(cpu))
			schedule();

		set_current_state(TASK_RUNNING);

		while(softirq_pneding(cpu)){
			do_softirq();
			if(need_resched())
				schedule();
		}
		set_current_state(TASK_INTERRUPTIBLE);
	}

	只要有等待处理的软中断(由softirq_pending()函数负责发现),ksoftirq就会调用do_softirq()
	去处理它们.通过重复执行这样的操作,重新触发的软中断也会被执行.如果有必要的话.
	每次都会调用schedule()以便让更重要的进程得到处理.

	只要do_softirq()函数发现已经执行过内核线程重新触发了它自己,软中断内核线程
	就会被唤醒.

8.3.3 老的BH机制

	




git lg

只要在命令行输入以下命令回车：
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
然后再git lg就可以看到彩色的日志。

注意:可以给每个提交都打个版本号,这样就可以随时切换到一个版本进入测试和工作.
Mod: remove unused code, 表示修改（Modify）
Add: a new module to have faster process, 表示新增（Add）
Rem: deprecate unused modules, 表示移除（Remove）
Ref: improved the implementation of module X, 表示重构（Refactory）

	


	

