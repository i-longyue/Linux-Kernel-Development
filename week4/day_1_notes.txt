5.1 与内核通信
	系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层的主要作用有三个。
	一：它为用户提供了一种硬件抽象接口。

	二：系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核
	可以基于权限，用户类型和其他一些规则对需要的访问进行对需要的访问进行决定。

	三：在第三章提到过，每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分
		提供这样一层公共接，也是出于这考虑。如果应用应用程序可以随意访问硬件而
		内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现
		良好的稳定性和安全性。
		
		
		在Linux中，系统调用是用户空间访问内核的唯一手段，除异常和陷入外，它们是内
		核唯一的合法入口。实际上，其他的像设备文件和/proc之类的方式，最终也还是要
		通过系统调用进行访问的。而有趣的是，Linux提供的系统调用却比大部分操作系统
		少得多。本章重点强调Linux系统调用的规则和实现方法。


5.2 API,POSIX 和C库
	一般情况下，应用程序通过在用户空间实现的应用编程接口API
	而不是直接通过系统调用编程。
	
	这点很重要，因为应用程序使用的这种接口实际上并不需要和内核提供的系统调用
	对应。一个API定义了一组应用程序的编程接口。它们可以实现一个系统调用，也可以通过
	多个系统调用来实现，而完全不使用系统调用也不存在问题。实际上，API可以在各种不同
	操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统的实现却可能
	迥异。


		调用printf() ---> c库中的printf() --- c库中的write() ----> write()系统调用
		应用程序                        c库                      内核

	在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE
	的一级标准组成，其目标是提供一套大体上基于Unix的可移植操作系统标准。在应用场合，
	Linux尽力与POSIX和SUSV3兼容。

	POSIX是说明API和系统调用之间关系的一个极好例子。在大多数的Unix系统上，根据POSIX定义的API
	函数和系统调用之间有着直接关系，实际上，POSIX，标准就是仿照早期Unix系统的接口建立的，另
	一方面，很多操作系统，像微软的dows，尽管是Unix系统，也提供了与POSIX兼容的库。

	Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供。C库实现了Unix系统的主要API,包括
	标准C库和系统调用接口。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以
	很方便地把它们封装起来使用。此外，C库提供了POSIX的绝大部分API。

	从程序员角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用
	打交道：库函数及应用是怎么使用系统调用，不是内核所关心的，但是，内核必须时刻牢记系统调用
	所有潜在的用途，并保证它们良好的通用性和灵活性。

	关于Unix的接口设计有一句格言“提供机制而不是策略”
	换句话说，Unix的系统调用抽象出了用于完成某种确定的目的的函数。至于这些函数怎么用，
	完全不需要去内核关心


5.3 系统调用(在Linux中常称作syscall),通常通过C库中定义的函数调用来进行。它们通常都需要
定义零个，一个或几个参数(输入)而且产生一些副作用.(注意这里用的是可能,尽管绝大部分调用都会产生
	某种副使用(就是说,它们会使系统的状态发生某种变化),但还是有一些系统调用,如getpid(),
	仅仅返回了一些内核数据.)

	例如，写某个文件或给定指针拷贝数据等。系统
	调用还会通过一个long类型的指针值来表示成功或者错误。通常但也不绝对，系统调用在出现错误的时候

*	C库会把错误码写入errno全局变量。通过调用perror()库函数，可以把该变量译成用户可以理解的错误
	字符串。

		当然，系统调用最终具有一种明确的操作，例如getpid()系统调用,根据定义它会返回当前进程的PID。
	内核中它的实现很简单。

	SYSCALL_DEFINE0(getpid)
    {
		return task_tgid_vnr(current); // returns current->tgid
    }

	内核必须提供系统调用希望完成的功能,但它完全可以按照自己的方式去实现,只要最后结果正确就行了.
	上面的调用太简单,也没有什么更多的实现手段
	(你可能会想为什么getpid()返回的是tgid(即线程组ID)),原因在于对于变通进程来说TGID和PID相等.
	对于线程来说,同一线程组内,所有的线程其TGID都相等.

	SYSCALL_DEFINE0只是一个宏,它定义一个无参数的系统调用(因此这里为数字0)
	展开的代码如下:
		asmlinkage long sys_getpid(void)

    我们看一下如何定义系统调用，首先，注意函数声明中的asmlinkage限定词，这是一个编译指令，通知
	编译器仅从栈中提取函数的参数。所有的系统调用都需要这个限定词。其次，函数返回long。为了保证
	32位和64位系统的兼容，系统调用在用户空间和内核空间有不同的返回值类型，在用户空间为int，在
	内核空间为long，最后，注意在系统调用get_pid内核中被定义成sys_getpid。这是Linux中所有系统调用
	都该遵守的命名规则,系统调用bar()在内核中也实现为sys_bar()函数


5.3.1 系统调用号
	在linux系统中,每个系统调用被赋予一个系统调用号.
	这样,通过这个独一无二的号,就可以关联在系统调用.当用户空间的进程执行一个系统调用的时候,这个调
	用号就用来指明到底执行哪个系统调用,进程不会提及调用的名称.

	系统调用号相当重要,一旦分配就不能再有任何变更,否则编译好的应用程序就会崩溃.此外,如果一个系统
	调用被删除,它所占用的系统调用号也不允许被回收利用,否则,以前编译过的代码会调用这个系统调用,但
	事实上却调用的是另一个系统调用.Linux有一个"未实现"系统调用sys_ni_syscall(),它除了返回-ENOSYS
	外不做任务其他工作,这个错误号就是专门针对无效的系统调用而设的.虽然委罕见,介如果一个系统调用
	被删除,或者変得不可用,这个函数就要负责.

		内核记录了一个系统调用表演中的所用已注册过的系统调用列表,存储在sys_call_table中.第
	一种上体系结构中,都明确定义了这个表,在X86-64中,它定义于arch/i386/kernel/syscall_64.c
	文件中.这个表为每一个有效的系统调用指定了一个唯一的系统调用号.
	


5.3.2 系统调用的性能 
	Linux系统调用比其他许多操作系统执行得要快.Linux很短的上下文件切换时间是一个重要原因,进出内核
	都被优化得高效.另一个原因是系统调用处理程序和每个系统调用本身也简洁.




5.4 系统调用处理程序
	用户空间的程序无法直接执行内核代码.它们不能直接调用内核内核空间的函数.因为内核驻留在受保护
	的地址空间上,如果进程可以直接在内核的地址空间上读写的话,系统的安全性和稳定性将不存在.

	所以,应用程序以某种方式通知系统,告诉内核自己需要执行一个系统调用,希望系统切换到内核态,这样
	内核就可以代表应用程序在内核空间执行系统调用.


	(软中断陷入进去,然后就是靠软中断实现的:通过引发一个异常来促使系统切换到内核态去执行异常处理
	 程序.)

	*通知内核的机制是软中断实现的:通过引发一个异常促使系统切换到内核态去执行异处理程序.此时的异常
	处理程序.

	实际上上就是系统调用处理程序.在X86系统上定义软中断是中断号128,通过int $0x80指令触发该
	中断. 这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序,而该程序正是系统调用
	处理程序.这个处理程序名字system_call(),它与硬件体系结构紧密相关,X86-64.S文件中用汇编语言编写
	增加一个一条sysenter的指令.与int中断指令相比,这条指令提供了很快更专业的陷入内核执行系统调用的
	方式.对这条指令的支持很快被加入内核.

5.4.1 指定恰当的系统调用
	因为所有的系统调用陷入内核的方式都一样.所以仅仅是陷入内核空间是不够的
	
	.因此必须把系统调用号一并传给内核.在X86上,系统调用号是通过eax寄存器传输给内核的.
	在陷入内核之前,用户空间就把相应系统调用所对应的号放入eax中,这样系统调用处理程序
	一旦运行,就可以从eax中得到数据.其他体系结构上的实现也都类似.

	system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性.如果它大于或者等待
	NR_syscalls,该函数就返回-ENOSYS.否则,就执行相应的系统调用:
	call *sys_ call_table(,%rax, 8)  (明显是从那个寄存器中读出来的.)

	由于系统调用表中的表项是以64位置类型存放的,所以内核需要将给定的系统调用号*4.

5.4.2 参数传递
	除了系统调用号以外,大部分系统调用都还需要一些外部的参数输入.所以,在发生陷入的时候,应该把
	这些参数从用户空间传给内核.最简单的办法就是像传递系统调用号一样,把这些参数也存放在寄存器
	里.ebx ecx edx esi edi按照顺序存放前5个参数.需要六个以上参数的情况不多见,此时,应该用一个
	单独的寄存器存放指向所有这些参数在用户空间地址的指针.

	调用read    read()封装例程                 system_call()                sys_read()

	应用         C库                             系统调用处理程序           sys_read()

	给用户空间返回值也通过寄存器传递.在X86系统上,它存放在eax寄存器中.


5.5 系统调用的实现
	实际上,一个Linux的系统调用在实现时并不需要太关心,它和系统调用处理程序之间的关系.给Linux添加
	一个新的系统调用是件相对容易的工作.怎样设计和实现一个系统调用是难题所在,而把它加到内核里却
	无须太多周折.让我们关注一下实现一个新的Linux系统调用所需的步骤.

5.5.1 实现系统调用
	实现一个新的系统调用的第一步是决定它的用途.它要做些什么?每个系统调用都应该有一个明确的用途.
	在Linux中不提倡彩多用途的系统调用.(一个系统调用通过传递不同的参数值来选择完成不同的工作)

	*ioctl()就是一个很好的例子,告诉了我们不应当去做什么.
	新系统调用的参数,返回值和错误码又该是什么呢?
	
	设计接口的时候要尽量为将来多做考虑.你是不是对函数做了不必要的限制?系统调用设计得通用好.
	记住Unix的格言:"提供机制而不是策略"

	当你写一个系统调用的时候,要时刻注意可移植性和健壮性,不但要考虑当前,还要为将来做打算.基本
	的Unix系统调用经受住了时间,它们中的很大一部分现在还和30年前一样适用.


5.5.2 参数验证
	系统调用必须仔细检查它们所有参数是否合法有效.系统调用在内核空间执行,如果任由用户将
	不合法的传递给内核,那么系统的安全和稳定将面临极大的考验.

	举例来说,与文件i/o相关的系统调用必须检查文件描述符是否有效.与进程相关的函数必须检查提供的PID
	是否有效.必须检查每个参数.保证它们不但合法有效,而且正确.进程不应当让内核去访问那些它无权访问
	的资源.

	最重要的一种上检查就是用户提供的指针是否有效,在接收一个用户空间指针之间,内核必须保证:
	*指针指向的内存区域属于用户空间.进程决不能哄骗内核去读内核空间的数据.
	*指针指向的内存区域在进程的地址空间里.进程决不能哄骗内核去读其他进程的数据.
	*如果是读,该内存应被标记为可读;如果是写,该内存应被标记为可写:如果是可以执行
	该内核被标记可执行.


	内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回copy.注意,内核无论何时
	都不能轻率地接受来自内核空间的指针!这两个方法中必须有一个经常被使用.
	为了向用户空间写入数据,内核提供了copy_to_user(),它需要三个参数.第一个参数是进程空间中的目的
	内存地址,第二个是内核空间内的源地址,最后一个参数是长度.

	如果执行失败,这两个函数返回的都是没能完成拷贝的数据的字节数.如果成功,则返回0.当出现了上述
	错误时,系统调用返回标准-EFAULT.

	让我们以一个既用了copy_from_user() 又用了copy_to_user()的系统调用作为例子进行考察.这个系统
	调用silly_copy()毫无实际用处,它从第一个参数里copy数据到第二参数.这种用途让人无法理解.它毫无
	必要地让内核空间作为中转站,把用户空间的数据从一个位置复制到另一个位置.但它却能演示出上述函数
	的用法.

SYSCALL_DEFINE3(silly_copy, 
		unsigned long *, src,
		unsigned Long *, dst,
		unsigned long  len)
{
	unsigned long buf;
	if(copy_from_user())
		return -EFAULT;

	if(copy_to_user())
		return -EFAULT;
	return len;
}

注意,copy_to_user()和copy_from_user()都有可能引起阻塞.当包用户数据的页被换出到硬盘上而不是在
物理内存上的时候,这种情况就会发生.此时,进程就会休眠,直到处理程序将该页从硬盘重新挽回物理内存.

最后一项检查针对是否有合法权限.在老版本的Linux内核中,需要超级用户权限的系统调用才可以通过调用
才可以通过调用suser()函数这个标准动作来完成检查.这个函数只能检查用户是否为超级用户:现在它已经
被一个更细粒度的"权能"代替.新的系统允许检查针对特定资源的特殊权限.调用者可以使用capable()函数
来检查是否有权能对指定的资源进行操作,如果它返回非0值,调用者可以使用capable()函数来检查是否有权
对指定的资源进行操作,如果返回非0,调用者就有权进行操作,返回0则无权操作.举个例子
capable(CAP_SYS_NICE)可以检查调用者是否有权改变其它进程的nice值.


下面是reboot()系统调用,注意,第一步是如何确保调用进程具有CAP_SYS_REBOOT权能.如果那样一个条件语句
被删除,任何进程都可以启动系统了.

/* 我们只信任启动系统的系统管理员 */
if (!capable(CAP_SYS_BOOT))
	return -EPERM;
	参见<Linux/capability.h>,其中包含一份所有这些权能和其对应的权限的列表.

5.6 系统调用上下文
	第3章节中曾讨论过,内核在执行系统调用的时候处于进程上下文.current指针指向当前任务,即引发系统
	调用的那个进程.
	在进程上下文中,内核可以休眠(比如在系统调用阻塞或显式调用schedule()的时候)并且可以被抢占.这
	两点很重要.首先,能够休眠说明系统调用可以使用内核提供的绝大部分功能.  

	在第7章中我们会看到,休眠的能力会给内核带来极大便利.在进程上下文中能够被抢占其实表明.像用户
	空间一样,当前的进程同样可以被其他进程抢占.因为新的进行可以使用相同的系统调用,所以必须小心
	保证该系统调用是可以重入的.当然,这也是在对称多处理器中必须同样关心的问题.

	当系统调用返回的时候,控制权仍然在system_call()中,它最终会负责切换到用户空间,并让用户进程
	继续执行下去.


5.6.1  绑定一个系统调用的最后步骤
	当编写完一个系统调用后,把它注册成一个正式的系统调用是件琐碎的工作:
	1)首先,在系统调用表的最后加入一个表项.每种支持该系统调用的硬件体系都必须做这样的工作
	(大部分的系统调用都针对所有的体系结构).从0开始算起,系统调用在该表中的位置就是它的系统调用号.


	2)对于所有支持的各种体系结构,系统调用号都必须定义于<asm/unistd.h>中
	3)系统调用必须被编译进内核映像,这只要把它放进kernel/下的一个文件就可以了,比如sys.c它包含了
	各种各样的系统调用.

	让我们通过一个虚构的系统调用foo()来仔细观察一下这些步骤.首先,我们要把sys_foo加入到系统调用
	表中去.对于大多数体系结构来说,该表位于entry.s文件中,形式如下:
		
	把新的系统调用加到这个表的末尾.
	.long sys_foo
	虽然没有明确指定编号,但我们加入这个系统调用按次序分配了338这个调用号.

	最后我们来实现foo()系统调用.无论何种配置,该系统调用都必须编译到核心内核映像中去.

	asmlinkage long sys_foo(void)
	{
		return THREAD_SIZE;
	}

*5,6.2 从用户空间访问系统调用
	通常,系统调用靠C库支持.
	用户程序通过包含标准头文件和C库链接,
	就可以使用系统调用(或者调用库函数,再由库函数实际调用).
	但如果你仅仅写出系统调用,glib库恐怕并不提供支持.

	值得庆幸的是,Linux本身提供了一组宏,用于直接对系统调用进行访问.它会设置好寄存器并调用陷入
	指令.

	这些宏是_syscalln(),其中n的范围从0到6,代表需要传递给系统调用的参数个数,这是由于该宏必须了
	解到底有多个参数按照什么次序压寄存器,举例
	open()系统调用的定义是:
		long open(const char *filename, int flags, int mode)
	而不靠库支持,直接调用此系统调用的宏形式为:

	#define NR_open 5
	__syscall3(long, open, const char*, filename, int, flags, int, mode)
	这样,应用程序就可以直接使用open();




	对于每个宏来说,都是2+2*n个参数.第一个参数对应着系统调用返回值类型.
	第二个参数是系统调用的名称.
	
	再以后是按照参数的顺序排序的每个参数的类型和名称.
	_NR_open在<asm/unistd.h>中定义,是系统调用号,该宏被扩展成为内嵌汇编的c函数,由汇编语言
	执行前面内容中所讨论的步骤,将系统调用号和参数压入寄存器并触发软中断来陷入内核.
	调用open()


	让我们写一个宏来使用前面编写的foo()系统调用,然后再写测试代码炫耀一下我们所做的努力.
	#define __NR_foo 283
	__syscall0(long, foo)

int main()
{
	long stack_size;
	stack_size = foo();
	return 0;
}
	
5.6.3 为什么不通过系统调用的方式实现
	前面的内容已经告诉大家,建立一个新的系统调用非常容易.
	如何给一个新的系统调用加警告和限制.通常都会有更好的办法用来代替新建一个系统调用以作实现.
	让我们看看采用系统调用作为实现方式的利和替代的方法.

	建立一个新的系统调用的好处:
	系统调用创建容易且使用方便.
	Linux系统调用的高性能显而易见

	*问题是:

	*你需要一个系统调用号,而这需要一个内核在处于开发版本的时间由官方分配给你.
	*系统调用被加入稳定内核后就被固化了,为了避免应用程序的崩溃,它的接口不允许做改动.
	*需要将系统调用分别注册到每个需要支持的体系结构中去.
	*在脚本中不容易调用系统调用.
	*由于你需要系统调用号,因此在主内核树之外是很难维护和使用系统调用的.
	*如果仅仅进行简单的信息交换,系统调用就大板小用了.

	替代方法:
	实现一个设备节点,并对此实现read()和write().使用ioctl对特定的设置进行操作或者特定的信息
	进行检索.
	(ioctl为什么会出现gg
	(1)虽然在文件操作结构休"struct file_operations"中有很多对应的设备操作函数,但是有些命令
	实在找不致电对应的操作函数.如CD-rom想要一个弹出光驱的操作,这种操作并不是所有的字符都需要
	的,所以文件操作结构体不会有对应的函数操作.

	(2)大部分驱动除了需要具备读写设备能力之外,还需要对设备的控制能力
	(3)编写应用程序
	没办法归类的函数就统一放在iocl这个操作函数中,通过指定命令来实现对应的操作.



	*像信号量这样的某些接口,可以用文件描述符来表示,因此也就可以按上述方式对基进行操作.
	*把增加的信息作为一个文件放在sysfs的合适位置.
	对于许多接口来说,系统调用都被视为正确的解决之道,但Linux系统尽量避免每出现一种新的抽象

	就简单加入一个新的系统调用.


5.7 小结
	在本章,我们描述了系统调用到底是什么,它们与库函数和应用程序接口API有怎样的关系.然后,我们
	考察了Linux内核如何实现系统调用,以及执行系统调用的连锁返回:陷入内核,传递系统调用号和参数
	,执行正确的系统调用,并把返回值带回了用户空间.

	然后,我们讨论了如何增加系统调用,并提供了从用户空间调用系统调用的简单例子.整个过程相当
	容易!增加一个新的系统调用没有什么难的,这一过程也就是系统调用的实现过程.本书的其余部分讨论
	了编写规范的,最优化的,安全的系统调用所遵循的概念和内核接口规范.

	最后,我们通过了讨论实现系统调用的优以及列举了其替代方案的形式对全章内容进行了总结.
	









