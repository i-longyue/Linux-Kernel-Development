/*----------------------------------------------------------------------------*/
2019-02-21  日志
此命令是遍历所有的git仓库，并在每个仓库执行-c所指定的命令。
-- eg:
-- 切换分支
-- repo formall -c git checkout dev_test
-- 删除分支 
-- repo forall -c git branch -D dev_test
-- 丢弃分支
-- repo forall -c git reset --hard (提交原始ID)
-- repo forall -r framework/base/core -c git reset --hard (提交原始ID)

2.source lunch的含义
-- source命令的功能：使用shell读入指定的Shell程序文件并依次执行文件中的所有语句。
-- source命令常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销重新登录。
-- lunch用于选择平台。
/*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/
2.2 内核源码树 
	内核源码树由很多目录组成，而大多数目录又包含更多的子目录。源码树的根目录及其
	子目录如下：

	arch                              特定体系结构的源码
	block                             块I/O层
	crypto                            加密API
	Documentation                     内核源码文档
	drivers                           设备驱动程序
	firmware                          使用某些驱动程序而需要的设备固件
	fs                                VFS和各种文件系统
	include                           内核头文件
	init                              内核引导和初始化
	ipc                               进程间通信代码
	kernel                            像调度程序这样的核心子系统
	lib                               通用内核函数
	mm                                内存管理子系统和VM
	net                               网络子系统
	sample                            示例，示范代码
	scripts                           编译内核所用的脚本
	security                          Linux安全模块
	sound                             语音子系统
	usr                               早期用户空间代码
	tools                             在Linux开发中有用的工具
	virt                              虚拟化基础结构

2.3 编译内核
2.3.1 配置内核
	内核提供了各种不同的工具来简化内核配置，最简单的一种是一个字符界面下的命令行
	工具
	make config
	该工具会逐一要求用户选择yes no或者是module

	make menuconfig
	make gconfig
	这条命令会基于默认的配置为你的体系创建一个配置：
	make defconfig
	尽管这些缺省值有点随意，这些配置会被存放在内核根目录下的.config文件中。你很容
	易就能找到。
	事实上，在编译内核之前你都应该这么做。把完整压缩过的内核文件存放在/proc/conf
	ig.gz下，这样当你编译一个新内核的时候就可以方便复制配置。
	一旦配置好，就可以使用一个简单的命令来编译它了。

2.3.2 减少编译的垃圾信息
	make > ../detritus
	一旦你需要查看编译的输出信息，你可以查看这个文件。不过，因为错误和警告都会在
	屏幕
	make > /dev/null

2.3.3 衍生多个编译作业
	make -jn
	make -j32  在16核的机器上

2.3.4 安装新内核
	在内核编译好后，你还需要安装它。Boot Loader
	以root身份，只要运行：
	make module_install
	就可以把编译的模块安装到正确的主目录 /lib/modules下。
	编译时也会在内核代码树中创建一个System.map文件。这是一份符号对照表。

2.4 内核开发的特点
	相对于用户空间内应用程序的开发，内核开发有一些独特之处:
	.内核编程时既不能访问C库也不能访问标准的C头文件
	.内核编程时必须使用GNU C
	.内核编程时缺乏像用户空间那样的保护机制。
	.内核编程时，难以执行浮点运算。
	.内核给每个进程只有一个定长堆栈。
	.由于内核支持异步中断，抢占和SMP，因此必须时刻注意同步和并发。
	.要考虑可移植性的重要性。

2.4.1 无libc库抑或无标准头文件
	大多数常用的C库--哪怕是它的一个子集，都太大且太低效了。常用的C库在内核中都有
	实现。
	头文件：内核源代码文件不能包含外部头文件。基本的头文件在顶级目录下的includ目
	录中。

	体系结构相关的头文件位于arch/include目录下。

	在所有没有实现的函数中，最著名的就数printf()函数了。内核代码虽然无法调用
	printf，但是它提供了printk()函数几乎和printf()相同？
	(平台在Linux服务器上写一个printf是什么样的原理)
	printk()函数负责把格式化好的字符串拷贝到内核日志缓冲上，这样，syslog程序就
	可以通过读取该缓冲区来获取内核信息。
	区别于printf
	可以通过一个标志 来设置优先级
	printk(KERN_ERR "this is an error!\n");
	在KERN_ERR和要打印的消息之间没有逗号，这样写是别有用意的，优先级标志是预处理
	定义的一个描述性字符串，在编译时优先级标志就与要打印的标志绑在一起处理。

2.4.2 GNU C
	内核并不完全符全ANSI
	C标准。实际上只要有可能，内核开发者总是要用到gcc提供的许多语言扩展部分。
	gcc是多种GNU编译器的集合,Linux内核用到C99。

	1.内联函数 (inline) 直接展开，被常常调用的函数，不建议把它做成内联函数。
	static inline void wolf(unsigned long size),要在使用之前就定义好，否则
	编译器没法把这个函数展开。一般在头文件中定义内联函数.


	2.内联汇编
	gcc编译器支持在C函数中嵌入汇编代码。
	unsigned int low,high;
	asm volatile("rdtsc":"=a"(low),"=d" (high));

	3.分支声明
	对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该
	条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核
	把这条指令封装成宏，

	if(error){
	}

	if(unlikely(error)){            /* 这个分支使用的更为广泛 */
	}

	if(likely(success)){
	}

2.4.3 没有内存保护机制
	在内核中不应该去做访问非法的内存地址，引用空指针之类。
	此外在内核中的内存不分页，也就是说，你每用掉一个字节，物理内存就减少一个字节
gg	所以，在你想往内核里加入什么新功能的时候，要记住这一点。

2.4.4 不要轻易在内核中使用浮点数
	在用户空间，内核会捕获陷阱并着手于整数到浮点方式,内核空间不能完美的支持浮点
	操作，因为它本身不能陷入。


2.4.5 容积小而固定的栈
	32位机是8K，64位机是16K。

2.4.6 同步和并发
	内核中许多特性要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争
	条件，特别是：
	.Linux的调度程序即兴对进程进行调度和重新调度。内核必须和这些任务同步。
	.Linux支持对称多处理器系统(SMP)
	.中断是异步的。
	.Linux内核可以抢占。
	常用解决竞争的办法是自旋锁和信号量。

2.4.7 可移植的重要性
	如保持字节序，64位对齐，不假定字长和页面长度等一系列准则都有助于移植性。

2.5 小结
	本章节和以前章节为贯穿本书剩余章节所讨论的主题奠定了基础，在后续的第一章中，
	我们都会覆盖一个具体的概念或了系统。在探索的征途中，最重要的是要阅读和修改
	内核源代码，只有通过实现的阅读和实践才会理解内核。
/*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*/
第3章 进程管理
	涉及进程的定义以及相关概念，比如线程，然后讨论Linux内核如何管理每个进程，
在内核中如何被创建，最终如何消亡，我们拥有操作系统就是为了运行用户程序，因此
进程管理就是所有操作系统的心脏所在。

3.1 进程(进程和线程的区别:进程的概念包括两个特点
	.资源所有权：进程具有一个虚拟的内存空间用来访问程序和数据
	.调度/执行：在进程执行时，进程具有不同的执行状态和分配优先级)


	进程就是处于执行期的程序???。
	但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，textsection)。
通常进程还要包含其他资源，像打开文件，挂起信号，内核内部数据，处理器状态。

	一个或多个具有内存映射的内存地址空间及一个或多个执行线程，当然还包括用来存
放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。


	执行线程，简称线程(thread),是在进程中活动的对象。
	每个线程都拥有一个独立的程序计数器，进程栈和一组进程寄存器。
	内核调度的对象是线程，而不是进程。在传统的Unix系统中，一个进程只包含一个线程
	但在现在系统中包含多个线程的多线程程序很多，Linux线程和进程并不特别区分。
	线程只不过是一种特殊的进程罢了。
	
	在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。
	虽然实际上可能是许多进程正在分享一个处理器，但虚拟处理器给进程一种假象。
	让进程觉得自己在独享处理器。第4章将详细描述这种虚拟机制。

	而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。
	第12章描述这种内存机制。有趣的是，注意在线程之间可以共享虚拟内存，但每个都拥
	有各自的虚拟处理器。(指同一进程中的线程)

	程序本身并不是进程，进程是处于执行期的程序以及相关资源的总称。
	实际上，完全可能存在两个或多个不同的进程执行的是同一个程序，
	并且两个或两个以上并存的进程可以共享许多诸如打开的文件，地址空间之类的资源。

	无疑，进程在创建它的时刻开始存活。
	在Linux系统中，这通常是调用fork()系统的结果。
	该系统调用通过复制一个现有进程来创建全新的进程。
	调用fork()的进程称为父进程，新产生的进程称为子进程。

	在该调用结束时，在返回这个点相同位置上，父进程恢复执行，子进程开始执行。
	fork()系统调用从内核返回两次，一个回到父进程，另一次回到新产生的子进程???。

	通常，创建新的进程都是为了立即执行新的，不同的程序，而接着调用exec()这组函数
	就可以创建新的地址空间，并把新的程序载入其中。在现代Linux内核中，fork()实际上
	是由clone()系统调用实现的,后者将在后面讨论。


	最终程序通过exit()系统调用退出执行。这个函数会终结进程并将其占用的资源释放掉。
	父进程可以通过wait4()系统调用查询子进程是否终结，这其实使得进程拥有了等待特定
	进程执行完毕的能力。进程退出执行后被设置为僵死状态，???
	直到它的父进程调用wait()或者waitpid()为止。
	(wait4 wait waitpid wait3 wait4函数 返回关于终止进程的状态)

	注意：进程的另一个名字是任务，Linux内核通常把进程也叫做任务。本书会交替使用这
	两个术语，不过我所说的任务通常指从内核观点看到的进程 。



3.2 进程描述符及任务结构
	内核把进程的列表存放在叫做任务队列(task List)的双向循环链表中，链表中的每一项
	都是类型为task_struct，称为进程描述符。
	task_struct相对较大，在32位机器上，它大约有1.7K。
	进程描述符中包含的数据能完整地描述一个正在执行的程序，它打开的文件，进程的地
	址空间，挂起的信号，进程的状态，还有更多的信息见图3.1。

3.2.1 分配进程描述符 
	Linux通过slab???(什么是slab)分配task_struct结构，这样能达到对象复用和缓存着色
	的目的。
	(通过预先分配和重复使用task_struct,可以避免动态分配和释放所带来的资源消耗)
	
	由于现在使用slab分配器动态生成task_struct,所以只需要在栈底或者顶创建
	一个新的结构struct thread_info在文件<asm/thread_info.h>中定义如下：
	每个任务的thread_info结构在它的内核栈的尾端分配，结构中task域中存放的是指向该
	任务实际task_struct的指针。
	(寄存器较弱的体系结构不是引入thread_info结构的唯一原因，这个新建的结构使在
	汇编代码中计算偏移变得十分容易。)


3.2.2 进行描述符的存放
	内核通过一个唯一的进程标识值(process indentification value)或PID来标识每个
	进程。PID是一个数，表示为pid_t隐含类型，实际上就是一个int类型。
	为了与老版本的Unix和Linux兼容，PID的最大值为32768(short int短整形的最大值)
	内核把每个进程PID存放在它们各自的进程描述符中。
	


