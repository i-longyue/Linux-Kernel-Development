/*----------------------------------------------------------------------------*/
2019-02-22 日志
	今天主要是阅读手册代码及描述方式。
	主要是分析进程管理。

/*----------------------------------------------------------------------------*/
3.2.2 进程描述符的存放
	内核通过一个唯一进程标识值或PID来标识每个进程。PID是一个数，表示为pid_t隐含
	类型实际上就是一个int类型。
	为了与老版本的Unix和Linux兼容，PID的最大默认值设置为32756。

	这个最大值很重要，因为它实际上就是系统中允许同时存在进程的最大数目。尽管
	32768对于一般的桌面系统足够用了，但是大型的服务器可能需要更多的进程。
	这个值越小，转一圈就越快，本来数值大的进程比数值小的进程迟运行，但这样一来就
	破坏了这一原则。如果确实需要的话???。

	在内核中，访问任务通常需要获得指向task_struct的指针。
	实际上，内核中大部处理进程的代码都是直接通过task_struct进行的。因此，通过
	current宏查找到当前正在运行进程的进程描述符的速度就尤为重要。
	
	
	
	
	硬件体系结构不同，该宏实现也不同，它必须针对专门硬件体系结构做处理。
	
	有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程task_struct的指针，
	用于加速访问速度，而有些像X86这样的体系结构(其寄存器结构并不富余)，就只能
	在内核栈的尾端创建thread_info结构，通过计算偏移间接查找task_struct结构。

	
	在X86系统上，current把栈的后13位有效位屏蔽掉，用来计算出thread_info的偏移。
	这是通过 current_thread_info()函数来完成的。
	movl $-8192,%eax
	andl %esp,%eax
	这里假定栈的大小为8KB，当4KB栈启用时，就要用4096，而不是8192.
	最后，current再从thread_info的task域中提取并返回task_struct:
	current_thread_info() ->task;


3.2.3进程状态
	进程描述符的state域描述了进程的当前状态。系统中的每个进程都必然处于五种进程
	状态中的一种，该域的值也必为下列五种状态标志之一：

	TASK_RUNNING(运行)--进程是可执行的;它或正在执行，或者在运行队列中等待执行。
这是进程在用户空间中执行的唯一可能状态,这种状态也可以应用到内核空间中正在执行
的进程。

	TASK_INTERRUPTIBLE(可中断)--进程正在睡眠（也就是被阻塞），等待某些条件的达
	成。一旦这些条件达成，内核就会把进程状态设置为运行。
	处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行。


	TASK_UNINTERRUPTIBLE(不可中断???)--除了就算是接收信号也不会被唤醒或者准备投
	入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受
干扰或者等待事件很快就会发生是出现。由于此状态的任务对信号不做响应，所以
较之可中断状态，使用得较少。
(你就是你在执行ps(1)命令时，看到那些被标记为D状态而又不能被杀死的进程的原因，
由于任务将不响应信号，因此，你不可能给它发送SIGKILL信号，退一步说，即使有办法，
终结这样一个任务也不是明智的选择，因为该任务有可能执行重要的操作，甚至还可能
持有一个信号量)

	__TASK_TRACED--被其它进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。
	__TASK_STOPPED(停止)--进程停止执行，进程没有投入运行也不能投入运行。通常
这种状态发生在接收到时sigstop sigtstp sigttin sigttou等信号的时候，此外
在调试期间收到的任何信号都会进入这种状态。


3.2.4 设置当前进程状态
	内核中经常需要调整某个进程的状态。
	这时最好的使用set_task_state(task,state)函数：
	set_task_state(task, state);/* 将任务设置为 state */

	它等价于
	task->state = state;
	set_current_state(state)和set_task_state(current, state)含义是等同的。

3.2.5 进程上下文
	可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到时进程
的地址空间执行，一般程序在用户空间执行。当一个程序执行了系统调用或者触发
了某个异常，它就陷入了内核空间，此时，我们称内核“代表进程执行”并处于进程
上下文中，在此上下文current宏是有效的。
(除了进程上下文，我们将在第七章讨论中断上下文。在中断上下文中，系统不代表
进程执行，而是执行一个中断处理程序，不会有进程去干扰这些中断程序，所以此时不
存在进程上下文。)

除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出
的时候，程序恢复在用户空间会继续执行。

	系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口
才能陷入内核执行--对内核的所有访问都必须通过这些接口。

3.2.6 进程家族树
	Unix系统的进程之间存在一个明显的继承关系。所有进程都是PID为1的init进程的
后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本
(initscript)并执行相关程序，最终完成系统启动的整个过程。

系统中的每个进程必有一个父进程,相应的，每个进程也可以拥有零个或多个子进程。
进程间的关系存放在进程描述符中。每个task_struct都包含一个指向其父进程
task_struct叫做parent的指针，还包含一个称为children的子进程链表。

	所以，对于当前进程，可以通过下面的代码获得其父task_struct,叫做parent的指针，
还包含一个称为children的子进程链表。所以，对于当前进程，可以通过下面的代码
	获得其父进程的进程描述符：
	struct task_struct *my_parent = current->parent;
	同样，也可以按以下方式依次访问子进程：
    struct task_struct *task;
    struct list_head   *list;`
    list_for_eack(list,&current->children){
    	task = list_entry(list, struct task_struct, sibling);
    	/* task 现在指向当前的某个子进程 */
    }


	init进程的进程描述符是作为init_task静态分配的,下面的代码演示所有进程之间的关
	系：
	struct task_struct *task;
	for(task = curent; task != &init_task; task = task->parent);
	/* task现在指向init */

	实际上，你可以通过这种继承关系从系统的任何一个进程出发查找到任意指定的
其他进程。但大多数时候，只需要通过简单的重复方式就可以遍历系统中的所有进程。
这非常容易做到，因为任务队列本来就是一个双向的循环链表。对于给定的进程，获取链表
中的下一个进程：
	list_entry(task->tasks.next, struct task_struct, tasks)
	获取前一个进程的方法与之相同
	list_entry(task->tasks.prev, struct task_struct, tasks)

	这两个例程分别通过
next_task(task)宏和prev_task(task)宏实现。而实际上，for_each_process(task)宏
提供了依次访问整个任务队列的能力。每次访问，任务指针都指向链表中的下一个元素：
struct task_struct *task;

for_each_process(task)
{
	/* 打印出每一个任务的名称和PID */

}
注意：在一个拥有大量进程的系统中通过重复遍历所有的进程代价是很大的，因此
如果没有充足的理由，别这样做。


3.3 进程创建
	Unix的进程创建很特别，许多其他的操作系统都提供了产生(spawn)进程的机制，首先在
新的地址空间时创建进程，读入可执行文件，最后开始执行。Unix采用了与从不同的
实现方式。它把上述步骤分解到两个单独的函数中去执行：fork()和exec()。

	首先，
	fork()通过拷贝当前进程创建一个子进程
	子进程与父进程的区别仅仅在于PID(每个进程唯一)PPID(父进程的进程号，子进程将其
设置设置为被拷贝进程的PID)和某些资源和统计量(例如，挂起的信号，它没有必要被继承)

	exec()函数负责读取可执行文件并将其载入地址空间开始运行。把两个函数组合起来使
	用的效果跟其他系统使用的单一函数效果相似。
	exec()在这里指所有exec()一族函数。
	(exec()在这里指所有exec()一族的函数，内核实现了execve()函数，在此基础上，还
	实现了execlp(),execle(),execv()和execvp())。

3.3.1 写时拷贝
	传统的fork()系统调用直接把所有的资源复制给新创建的进程。
	这种实现过于简单并且效率低下。因为它拷贝的数据也许并不共享，更糟糕的情况是如
	果新进程打算立即执行一个新映像，那么所有的拷贝都将前功尽弃。

	Linux的fork()使用写时拷贝页???实现。
	也就是说资源的复制只有在需要写入的时候才进行，
	在此之前，只是以只读方式共享。这种技术使地址空间的页的拷贝被推迟到时实际发生
	写入的时候，在页根本不会被写入的情况下fork()后立即调用exec()它们无须复制。

	fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。

3.3.2 fork()
 	Linux通过clone系统调用来实现fork()。???
	这个调用通过一系列的参数标志来指明父子进程需要共享的资源。
	fork(),vfork(),__clone()库函数都根据各自需要的参数标志去调用clone(),
	然后调用clone()去调用do_fork()。

	do_fork完成了创建中的大部分工作，该函数调用copy_process()函数，然后让进程
	开始运行。copy_process()函数完成的工作很有意思：

	1）调用dup_task_struct为新进程创建一个内核栈，thread_info结构和task_struct
	这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。

	2）检查并确保创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的
	资源的限制。

	3）子进程着手使自己与父进程区别开来，进程描述符内的许多成员要清0或者设
	为初始值。那些不是继承而来

	4)子进程的状态被设置为TASK_UNINTERRUPTIBLE,以保证它不会投入运行。

	5）copy_process()调用copy_flags()以更新task_struct的flags成员。表明进程是
	否拥有超级用户权限的PF_SUPERPRIV标志被清0。表明进程还没有调用exec()函数的
	PF_FORKNOEXEC标志被设置。

	6)调用alloc_pid()为新进程分配一个有效的PID

	7)根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件，文件
	系统信息.信号处理函数，进程地址空间命令和命令空间等。
	在一般情况下，这些资源会被给定进程的所有线程共享，否则这些资源对每个进程是
	不同的。因此拷贝到这里。

	8)最后，copy_process()作扫尾工作并返回一个指向子进程的指针。
	再回到do_fork()函数。如果copy_process()函数执行成功返回，新创建的子进程被
	唤醒并让其投入运行。内核有意选择子进程首先执行。
	(虽然想让子进程先运行，但是并非总能如此。)
	因为一般子进程都会马上调用
	exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行，有可能会
	开始向地址空间写入。

3.3.3 vfork()
	除了不拷贝父进程的页表项外,vfork()系统调用和fork功能相同。

	子进程作为父进程的一个单独的线程在它地址空间里运行，父进程被阻塞，
	直到子进程退出或执行exec()。子进程不能向地址空间写入。在过去3BSD时期，
	这个优化是很有意义的。
	
	那时并未使用写时拷贝页来实现fork()。现在由于在执行fork()时引入了写时拷贝
	页并且明确了子进程先执行，vfork的好处就仅限于不拷贝父进程的页表项。

	vfork()系统调用的实现是通过向clone()系统传递一个特殊标志进行的。
	1)在调用copy_process()时，task_struct的vfor_done成员被设置为NULL。
	2)在执行do_fork()时，如果给定特别标志，则vfork_done会指向一个特定地址。
	3)子进程先开始执行后，父进程不是马上恢复执行，而是一起等待，直到子进程通过
	vfork_done指针向它发送信号。
	4)在调用mm_release()时，该函数用于进程 退出内存地址，并检查vfork_done是否
	为空，如果不为空，则会向父进程发送信号。
	5）回到do_fork(),父进程在新的地址空间运行而父进程也恢复了在原地址的运行。
	这样，开销确实降低了，不过它的实现并不是优良的。


3.4 线程机制在Linux中的实现 
	线程机制是现代编程技术中常用的一种抽象概念。
	该机制提供了在同一程序内共享地址空间运行的一组线程。
	这些线程还可以共享打开的文件和其他资源。线程机制支持并发程序设计技术，
	(concurrent programming)在多处理器系统上，它也能保证真正的并行处理。
	Linux实现线程机制非常独特，从内核角度来说，它并没有线程这个概念。
		

	linux把所有的线程都当做进程来实现。内核没有准备特别的调度算
	法或是定义特别的数据结构来表征线程。

	相反线程仅仅被视为一个与其他进程共享某些资源的进程。

	每个线程都拥有一个唯一隶属于自己的task_struct,
	所以在内核中，它看起来就像是一个变通的进程，
	(只是线程和其他一些进程共享某些资源，如地址空间。)

	上述线程机制的实现与Microsoft Window或是SunSolaris等操作系统的实现差异
	非常大。这些系统都在内核中提供了专门支持线程的机制。
	(这些系统常常把线程称作为轻量级进程)
	在其他系统中，相较于重量级进程，线程被抽象为一种耗费较少资源，运行迅速的执
	行单元。

	对于Linux而言它只是一种进程间共享资源的手段。

	for eg:
	有一个包含4个线程的进程
	，会有一个包含指向这四个不同线程的指针的进程描述符。该描述符负责描述像地址
	空间，打开文件这样的共享资源。线程本身再去描述它独占的资源。相反Linux仅仅创建
	四个进程并分配四个普通的task_struct结构，建立这四个进程时，指定它们共享某些
	资源，这是相当高雅的作法。

3.4.1 创建线程
	线程的创建和变通进程的创建类似。只是在调用clone()的时候需要传递一些参数标志
	来指明需要共享的资源：

	clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)

	上面代码的产生结果和调用fork()差不多，只是父子俩共享地址空间，文件系统资源，
	文件描述符和信号处理程序。换个说明法就是线程。
	对于一下，一个变通的fork()实现是：
	clone(SIGCHLD, 0)
	
	而vfork()的实现是:
	clone(CLONE_VFORK｜CLONE_VM | SIGCHLD,0)

	传递给cloner()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源
	种类.下面给出cloner()用到的参数标志及它们的作用.

	CLONE_FILES          父子进程共享打开的文件
	CLONE_FS             父子进程共享文件系统信息
	CLONE_IDLETASK       将PID设置为0(只提供idle进程使用)
	CLONE_NEWNS
	CLONE_PARENT
	CLONE_PTRACE
	CLONE_SETTID
	CLONE_SETTLS
	CLONE_SIGHAND
	CLONE_SYSVSEM
	CLONE_THREAD         父子进程放入相同的线程组
	CLONE_VFORK        
	CLONE_UNTRACED      
	CLONE_STOP      
	CLONE_SETTLS 
	CLONE_CHILD_CLEARTID 
	CLONE_CHILD_SETTID 
	CLONE_PATRENT_SETTID
	CLONE_VM

3.4.2 内核线程
	内核经常需要在后台执行一些操作。这种任务可以通过内核线程完成--独立运行在内核
	空间的标准进程,内核线程和变通的进程间的区别在于内核线程没有独立的地址空间,
	(实际上指向地址空间的mm指针被设置为NULL)。它们只在内核空间运行，从来不切换
	到用户空间去。可以被调度和抢占.


	Linux确实会把一些任务交给内核线程去做，像flush和ksofirqd这些任务注是明显的例
	子。在装有Linux系统的机子上运行ps-ef
	这些线程在系统启动时,由另外一些内核线程创建.实际上,内核线程也只能由其他
	内核线程创建,
	
	内核通过kthreadd内核进程中创建一个新的内核线程方法
	struct task_struct *kthread_create(int (*threadfn)(void *data),
										void *data,
										const char namefmt[],
										...)
	新的任务是由kthread内核进程通过clone系统调用而创建的。新的进程将运行threadfn
	函数，给其传输的参数为data，进程会被命名为namefmt，namefmt接受可变参数列表
	类似于printf()的格式化参数。新创建的进程处于不可运行状态，如果不通过
	wake_up_process()
	
	明确地唤醒它.它不会主动运行.创建一个进程并让它进行起来,可以通过调用
	kthread_run()来达到:
	这个例程是以宏来实现的，只是简单的调用了kthread()和wake_up_process();

	内核线程启动后就一直运行直到调用do_exit()退出。或者内核的其他问他调用kthread
	stop退出,传递kthread_stop()的参数为kthread_creadte()函数返回的task_struct
	结构的地址:

	int kthread_stop(struct task_struct *K)

3.5 进程终结。
	虽然让人伤感,但是进程终归是要终结的。
	当一个进程终结时,内核必须释放它所占有的资源，并把这一不幸告知其父进程。

	进行的析构(清理善后)，是自身引起的，它发生在进程调用exit()系统调用时，既
	可能显式地调用用这个系统调用，也可能隐式地从某个程序的主函数返回
	其实C语言编译器会在main()函数的返回点后面放置调用exit()的代码。

	当进程接受到它不能处理也不能忽略的信号或异样时,它还可能被动地终止，

	不管进程是怎么终结的该任务大部分都要靠do_exit()来完成，它要做下面这些烦琐的
	工作：

	1）将task_struct中标志成员设置为PF_EXITING.

	2) 调用del_timer_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器
	在排除，也没有定时器处理程序在运行。

	3)如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记
	账信息。

	4）然后调用exit_mm()函数释放进程占用的mm_struct,如没有别的进程使用它们(也就
	是说，这个地址空间没有被共享，就彻底释放它们。)

	5)接下来调用sem__exit()函数。如果进程等候IPC信号，它则离开队列。

	6)调用exit_files()和exit_fs(),以分别递减文件描述符，文件系统数据的引用计数。
	如果其中某个引用计数的数值降为零，那么就代码没有进程在使用相应的资源，此时
	可以释放。

	7)接着把存放在task_struct的exit_code成员中的任务退出代码置为exit()提供的退出
	代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程
	随时检索。

	8)调用exit_notify()父进程发送信号，给子进程重新找养父，养父为线程组中的其他线
	程或者为init进程，并把进程状态(存放在task_struct结构的exit_state中)设成EXIT_
	ZOMBLE。

	9)do_exit()调用schedule()切换到新的进程，因为处理EXIT_ZOMBIE状态的进程不会被
	再调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。

	至此，与进程相关联的所有资源都被释放掉了(假设该进程是这些资源的唯一使用者，
	)。进程不可运行（实际上是没有空间让它运行）并处于EXIT_ZOMBIE退出状态。它
	占用的所有的内存就是内核栈，thread_info结构和tast_struct结构。
	
	此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到时信息后，
	或者通知内核那里无关的信息后，由进程所持有的剩余的内存释放，归还给系统使用。

3.5.1 删除进程描述符

	在调用了do_exit()之后，尽管线程已经僵死不再运行了，但是系统还保留了它的进程
	描述符。前面说过，这样做可以让系统有办法在子进程终结后仍可以获得它的信息。

	因此，进程终结时所需的清理工作和进程描述符删除被分开执行。

	在父进程获得已终结子进程的信息后，或者通知内核它并不关注的那些信息，
	子进程的task_struct结构才被释放。

	wait()这一族函数都是通过唯一(但是很复杂)的一个系统调用wait4()来实现的。
	它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返
	回子进程的PID。此外，调用该函数提供的指针会包含子函数退出时的退出代码。 


	当最终需要释放进程描述符时，release_task()会被调用，用以完成以下工作：

	1)它调用__exit_signal(),该函数调用__unhash_process,后者又调用detach_pid()
	从pidhash上删除进程，同时也要从任务列表中删除该进程。

	2）__exit_signal()释放目前僵死进程所使用的剩余资源，并进行最终统计和记录。

	3）如果这个进程是线程组的最后一个进程，并且领头进程已经死掉，那么
	release_task()就要通知僵死的领头进程的父亲进程。

	4)release_task()调用的put_task_struct()释放进程内核栈和thread_info结构所
	占的页，并释放task_struct所占的slab高速缓存。

	至此，进程描述符和所有进程独享的资源注全部释放掉了。

3.5.2 孤儿进程造成的进退维谷
	果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这
	些孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。前面的部分已经有所
	暗示，对于这个问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果
	不行，就让init做它们的父进程，
	
	在do_exit()中会调用exit_notify(),该函数会调用
	forget_original_parent(),而后者会调用find_new_reaper()来执行寻父过程：

	static struct task_struct *find_new_reaper(struct task_struct *father)
	struct task_struct *thread;

	thread = father;
	while_each_thread(father, thread) {
		if()
			....
	}


	这段代码试图找到进程所在线程组内的其他进程。如果线程组内没有其他进程，它就
	找到并返回的是init进程。现在，给子进程找到合适的养父进程了，只需要遍历所有
	子进程并为它设置新的父进程：

	reaper = find_new_reaper(father);
	list_for_each_entry_safe(p,n,&father->children,silbing){
	}
	然后调用ptrace_exit_finish()同样进行新的寻父过程，不过这次是给ptraced的子进程
	寻找父亲。
	void exit_ptrace(struct task_struct *tracer)
	{

	}
		这段代码遍历了两个链表：子进程链表和ptrace子进程链表，给每个子进程设置新
	的父进程。这两个链表同时存在的原因很有意思，它也是2.6内核的一个新特性。

	当一个进程被跟踪时，它的临时父亲设定为调度进程。
	此时如果它的父进程退出了，系统会为它和
	它的所有兄弟重新找一个父进程。在以前的内核中，这需要遍历系统中所有的进程来找
	这些子进程。现在的解决办法是在一个单独的ptrace跟踪的子进程链表中搜索相关的
	兄弟进程--用两个相对较小的链表减轻了遍历带来的消耗。

	一旦系统为进程成功找到和设置了新的父进程，就不会出现驻留僵死进程的危险了。
	init进程会例行调用wait()来检查子进程，清除所有与其相关的僵死进程。


3.6 小结 
	在本章节中，我们考察了操作系统中的核心概念--进程。
	我们也讨论了进程的一般特性它为何如此重要，以及进程与线程之间的关系。
	然后，讨论了Linux如何存放和表示进程(task_struct和thread_info),如何创建进程
	(通过fork(),实际上最终是clone()),如何把新的执行映像装入到地址空间
	(通过exec()系统调用族）,如何表示进程的层次关系，

	父进程又是如何收集其后代的信息(通过wait()系统调用族),以及进程最终如何消亡
	(强制或者自愿地调用exit)。进程是一个非常基础，非常关键的抽象概念，位于每一种
	现代操作系统的核心位置，也是我们拥有操作系统(用来运行程序的最终原因)

	第4章讨论进程调度，内核以这种微妙而有趣的方式来决定哪个进程运行，何时运行，以
	何种顺序运行。

	ps auxf命令可以查看当前进程的状态。

	






