/*----------------------------------------------------------------------------*/
2019-02-20 日志
1.更换了装有java基础环境的服务器 172.16.19.108 账号密码longyao

	执行repo sync -l  
	发现一直在checkout发现是.ssh(公钥和私钥)没有拷贝过来,将.ssh拷贝过来,然后再
	执行repe sync 就可以同步代码了,同步完成会done标志。

	设定repo的版本库地址:
	repo init --repo-url ssh://git@www.rockchip.com.cn/repo/rk/tools/repo
	-u ssh://git@www.rockchip.com.cn/repo/rk/platform/manifest -b android-5.1
	-m rk3288_lollipop_release.xml
	(执行流程由错误中止了,没有理会这个问题)

2.出现error: vendor/google: contains uncommitted changes 
	去到问题目录vendor/google 执行git stash再repo sync

3.build.sh 和同步之前不一样,之前只有配置环境功能，没有包含执行生成uboot kernel
android的动作。
	修改build.sh脚本的配置参数为defconfig

4.android编译出错。
	a.发现java编译器版本没有一样,增加javaenv.sh文件,执行内容为：
	export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
	export PATH=$JAVA_HOME/bin:$PATH
	export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar

	b.error: unsupported reloc 43
	cp /usr/bin/ld.gold prebuilts/gcc/linux-x86/host/x86_64-linux-glibc2.11-4.6/
	x86_64-linux/bin/ld
	(以上是连接在一起的)

	c.No child processes 因为找不具体的error
	尝试重新编译(打开设备管理器的命令: devmgmt.msc)


	d.出现error 5: Added public field 
	执行make-api命令时，要注意的是先同步环境

	source build/envsetup.sh 
	这个命令是用来将envsetup.sh里所用到的命令加载到环境变量里去，
	(1.加载编译时使用到时的函数命令，help lunch
	 2.添加了两个编译选项
	 3.查找vendor/<-厂商目录->)

	lunch rk3288-userdebug
	(lunch命令是envsetup里面定义的一个命令，用来让用户选择编译项，来定义Product
	和编译过程中用到的全局变量
	eng 工程机
	user 最终用户机
	userdebug 调试测试机
	tests 测试机
	)

	执行make update-api

	e.make update-api之后还需要make如果不make之后的sdk中image.sh脚本的调用会显示
	生成不完全提示如下：
	please make first!!!

	执行make
	出现大量error这个目前怀疑是Linux服务器的问题，明天找安工。

	f.make找不到错误，clean后重新编译
	clean之后遇到一些找不到具体error的错误，于尝试几次重新编译(包括环境配置)
	之后就success了。

	g.烧入开发板程序可以正常跑起来。
/*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/
1.4 Linux内核和传统的Unix内核的比较

Unix内核几乎毫无例外的都是一个不可以分割的静态可执行库。
-- 也就是说，它们必须以巨大单独的可执行块的形式在一个单独的地址空间运行。
-- Unix内核通常需要硬件系统提供页机制
-- (MMU)以管理内存。这种页机制可以加强对内存空间的保护。并保证每个进程都可以运行
-- 于不同的虚拟地址空间。
-- ???什么是MMU
-- MMU工作过程,就是把虚拟地址映射到物理地址。

单内核和微内核设计之比较
操作系统内核可以分为两大阵营：单内核和微内核(第三陈营是外内核)
单内核:
-- 单内核是两大阵营中一种较为简单的设计，把它从整体上作为一个单独强大的过程来实现
-- 同时也运行在一个单独的地址空间上，因此这样的内核通常以单个静态二进制的形式存放
-- 磁盘中，所有内核服务都在这样的一个大内核地址空间在运行。内核之间通信是微不足道
-- 的，因为大家都运行在内核态，并身处同一地址空间，内核可以直接调用函数，这与用户
-- 空间应用程序没有什么区别。单模块具有简单和性能高的特点。大多Unix系统都设计为单
-- 模块。

微内核:
-- 并不作一个单独的大过程来实现。微内核的功能被划分为多个独立的过程，每个过程
-- 叫做一个服务器。理想情况，具有强烈请求特权服务的服务器才运行在特权模式下，其
-- 他服务器都运行在用户空间。不过，所有的服务器都保持独立并运行在各自的地址空间上
-- 因此，就不可能像单模块内核那样直接
-- 调用函数。而是通过消息传递处理微内核通信：系统采用进程间通信(IPC)机制服务器的
-- 各自独立有效的避免了一个服务器的失效祸及另一个，模块化的系统允许一个服务器
-- 为另一个服务器换出。

Linux是单内核，运行在单独的内核地址空间上:???
-- 模块化设计，抢占式内核，支持内核线程及动态装载模块的能力，
-- Unix的底蕴(就是API)
-- .Linux支持动态加载内核模块，尽管Linux内核是单内核,允许需要的时候动态的卸载和
-- 加载部分内核代码。
-- .Linux支持对称多处理机制(SMP).(同时处理多条指令。)
-- .Linux内核可以抢占(preemptive)，允许在内核运行的任务优先执行的能力。
-- .Linux对多线程支持的实现比较有意思，内核并不区分线程和其他一般进程,所有的进程都一
-- 样---只不过是其中的一些共享资源而已。
-- .Linux提供具有设备类的面向对象的设备模型，热插拔事件，以及用户空间的设备文件系统。
-- .Linux忽略了一些被认为是过时的Unix特性。
-- .Linux体现自由这个词的精髓。

1.5 Linux内核版本
	内核版本命名规则。

1.6 Linux内核开发社区
 	Linux kernel mailing list

1.7  小结
	这是一本关于Linux内核的书：内核的目标，为达到目标进行的设计以及实现。
	看这本书的时候，要有Linux系统的电脑，有linux源码。
/*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*/
第2章节  从内核出发 
	这一章节介绍Linux内核的一些常识：从何处获取源码，如何编译它，又如何安装新的内
核，内核程序和用户程序的差异，以及内核中所使用的通用。

2.1 获取内核源码
	可以通过访问官方网站获取当前版本的Linux源代码。

2.1.1 使用Git
	你可以使用Git来获取最新提交到Linus版本树的一个副本：
	git clone git:XXX

	当下载最新代码后，你可以更新你的分支到Linus的最新分支：
	git pull
	有了这两个命令，就可以获取并随时保持与内核官方的代码树一致。

2.1.2 安装内核源代码
	内核压缩以GNU zip(gzip)和bzip两种形式发布。bzip2是首选。
	bz2 j
	gz  z

	如何安装并触及源码
		内核源码一般安装在/usr/src/linux目录下。但请注意，不要把这个源码树用于开
	发，因为编译你的C库所用的内核版本就链接到这颗树。此外不要以root身份对内核进行
	修改，而应当建立自己主目录，仅以root身份安装新内核，即使安装新内核时，/usr
	src/linux/目录都应不动。

2.1.3 使用补丁
/*----------------------------------------------------------------------------*/
	






















