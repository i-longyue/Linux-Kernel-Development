
1.安装VM box ubuntu18.04出现虚拟机器不能打开任务的问题
	解决方法：打开支持硬件虚拟化的按钮。（HP电脑使用F10进入配置模式）


2.注意上下文切换也称作进程切换或任务切换，是指cpu从一个进程或线程切换到另一个进程
或线程。


4.4 Linux调度算法 
	在前面的内容中，我们抽象地讨论了进程调度原理，只是偶尔提及Linux如何把给定的
	理论应用到实际中。在已有的调度原理基础上，我们进一步探讨了具有Linux特色的
	进程调度程序。

4.4.1 调度器类
	Linux调度器是以模块方式提供的，这样做目的是允许不同类型的进程可以有针对性地
	选择调度算法。

	这种模块化结构被称为调度器类，它允许多种不同的可动态添加的调度算法并存，调度
	属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义在kernel/
	sched.c文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级
	的调度类胜出，去选择下面要执行的那一个程序。

	完全公平调度(CFS)是一个针对普通进程的调度类，在Linux中称为SCHED_NORMAL,CFS
	算法实现定义在kernel/sched_fair.c中本节下面的内容重点讨论CFS算法，该内容对
	于所有2.6.23以后的内核版本意义非凡。
	
4.4.2 Unix系统中的进程调度 
	在讨论调度算法前，我们必须认识下传统Unix系统调度过程。正如前面所述，现代进程
	调度器有两个通用的概念：进程优先级和时间片。时间片是指进程运行多少时间，进程
	一旦启动就会有一个默认时间片。具有更高的优先级和进程将运行得更加频繁，而且
	在多数系统上也会被赋予更多的时间片。在Unix系统上，优先级以nice值形式输出给
	用户空间。这点听起来简单，但是在现实中，却会导致许多反常的问题，我们下面具体
	讨论。

		这一个问题，若要将nice值映射到时间片，就必然需要nice单位值对应到处理器的
		绝对时间。但这样做导致进程切换无法最优化进行。举例说明，假定我们将默认
		nice值（0）分配一个进程-------对应的是一个100ms(???)

		同时再分配一个最高nice值(+20,最低的优先级)-------对应的时间片是5ms。
		我们接着假定上述两个进程都处于可以运行状态。那么默认优先级的进程将获得20/21
		(105ms中的100ms)的处理器时间，而低优先级的进程会获得1/21（105中的5ms）的
		处理器时间。我们本可以选择任意数值用于本例子中，但这个分配值正好是最具有
		说服力的，所以我们选择它。
		
		现在，我们看看如果运行两个同等低优先级的进程情况如何。我们希望它们各自获
		得一半的处理器时间，事实上也确实如此。但是任何一个进程每次仅仅只能获得5ms
		的处理器时间（10ms中各占一半）.也就是说，相比刚才例子中105ms内进行一次上
		下文切换，现在10ms内继续进行两次上下文切换

		类推，如果是两个具有普通优先级的进程，它们同样会每个获得50%处理器时间，但
		是在100ms内各获得一半。显然，我们看到这些时间片的分配方式并不很理想：它们
		是给定nice值到时间片映射与进程运行优先级混合共同作用结果。

		事实上，给定高nice值的进程往往是后台进程且多是计算密集型，而普通优先级的
		进程更多是前台用户任务。所以这种时间分配方式显然和初衷背道。


		第二个问题涉及相对nice值，同时和前面的nice值到时间片映射关系也脱不了干系。
		假设我们有两个进程，分别具有不同的优先级。第一个nice的值是只是0，第二个值
		假设是1.它们将被分别映射到时间片100ms和95ms（o(1)调度算法就是这么干了）。
		它们的时间片几乎一样，其差别微乎其微。但是如果我们的进程分别赋予了18和19
		的nice值，那么它们则分别被映射为10ms和5ms的时间片，如果这样，前者相比后者
		获得了两倍的处理器时间！不过 nice值通常都使用相对值（nice系统调用是在
		原值上增加或减少，而不是在绝对值上操作），也就说：”把进程的nice值减小1“
		所带来的效果极大地取决于其nice的初始值。

		第三个问题，如果执行nice值到时时间片的映射，我们需要能分配一个绝对时间片
		而且这个绝对时间片必须能在内核的测试范围内，在多数操作系统中，上述要求
		意味着时间片必须是定时器节拍的整数倍（请参考第11章”定时器和时间测量）。
		但这么做必然会引发几个问题。首先最小时间片必然是定时器节拍的整数倍，也就
		10ms或者1ms的倍数。其次系统定时器限制了两个时间片的差异：连续的nice值映射
		到时间片，其差别范围多到10ms或者少则1ms。最后，时间片还会随意定时器节拍
		改变

		第四个问题也是最后一个关于基于优先级的调度器为了优化交互任务而唤醒相关进程
		的问题。这种系统中，你可能为了进程能更快投入运行，而去对新要唤醒的进程
		提升优先级，即便它们时间片用尽了，虽然上述的方法确实能提升不少交互性能，
		但是一些例外情况也可能发生，因为它同时也给某些特殊的睡眠/唤醒用例一个玩弄
		调度器后门，使得给定进程打破公平原则，获得更多处理器时间，损害系统中其他
		进程的利益。

		上述问题中绝大多数都可以通过对传统Unix调度器进行改造解决，虽然这种改造
		修改不小，但也并非是结构性调整。比如，将nice值呈几何增加而非算数增加的
		方式解决第二个问题：采用一个新的度量机制将从nice值到时间片的映射与
		定时器节拍分享开来，以解决第三个问题。但是这些解决方案都回避了实质问题
		即分配绝对时间片引发的固定的切换频率，给公平性造成了很大变数。CFS采用
		的方法是对时间片分配
		方式进行根本性的重新设计（就进程调度器而言），完全摒弃时间片而分配
		给进程一个处理器比重，通过
		这种方式，CFS确保了进程调度中能有恒定的公平性，而切换频率置于不断变动中。





第11章  定时器和时间管理
	时间管理在内核中占有





















4.4.3 公平调度
	CFS的出发点基于一个简单的理念：进程调度的效果应如同系统中具备一个理想中的完美
	多任务处理器。在这种系统中，
	------


4.5 Linux调度的实现 
	在讨论了采用了CFS调度算法的动机和其内部逻辑后，我们现在可以开始具体探索CFS是
	如何得以实现的。其相关代码位于文件kernel/sched_fair.c中，我们将特别关注其四个
	组成部分：
	时间记账
	进程选择
	调度器入口 
	睡眠和唤醒




	

4.9 小结
	进程调度程序是内核重要的组成部分，因为运行着的进程首先使用计算机。（至
	少我们大多数人看来）。然而,满足进程调度的各种需要绝不是轻而易举的：很难
	找到“一刀切”的算法，既适合众多的可运行进程，又具有可伸缩性，还能调度周期
	和吞吐量之间求得平衡，同时还满足各种负载的需求。不过，Linux内核的新CFS
	调度程序尽量满足了各个方面的需求，并以较完善的可伸缩性和新颖的方法提供了
	最佳的解决方案。

	前面的章节覆盖了进程管理的相关内容，本章则考察了进程调度遵循的基本原理，具体
	实现，调度算法以及目前Linux内核所使用的接口。第5章将涵盖内核提供给运行进程的
	主要接口--------------系统调用。
	







