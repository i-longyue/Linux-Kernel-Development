1.windows secureCRT怎么使用串口调度肋手?
	将快速连接中SSH选择为serial就可以了。

2.怎么确认代码范围和尝试输出调试信息。
	大概的梳理了USB模块的代码
	在进行烧写程序的时候，有两道枚举代码分别对应如下：
	我们可以按住mask按键上电,这时电脑显示发现一个MASKROM设备，这道程序是固化在芯片内
	的，不可更改的程序,这是一个自定义高速设备。

	我们也可以在上电后按住recover键，然后按reset键，这里电脑显示发现一个Loader设备。
	这道程序是在uboot工程中实现的。
	大概的代码执行范围如下：

	common/board_r.c
	board_init_r通过调用init_call_run_list(init_sequence_r)将init_sequence_r的数组都
	执行了个遍

	rockchip/rockchip/rk32xx/rk32xx.c
	init_sequence_r数组中board_late_init函数
	board_late_init()

	rockchip/common/rkboot/fastboot.c
	board_fbt_preboot()


	rockchip/common/rkboot/fastboot.c
	board_fbt_get_reboot_type()


	rockchip/common/rkboot/fastboot.c
	/* 进行USB枚举 */
	do_rockusb(NULL,0,0,NULL)


	common/cmd_rockusb.c
	在do_rockusb中准备usb初始化内容，也是硬件初始化和数据结构准备。
	通过udc_connect注册usb中断响应程序。

	对不起setup包处理
	udc_irq->dwc_otg_out_intr->ep0_recv_setup

	综上这道程序是一道完全的裸机程序没有应用Linux USB Gadget框架。


	可以通过这个查看是不是最新的工程 ls .repo/manifests/rk3288_android-5.1_v1.00/ -l


3. 在编译uboot遇到了执行make命令时报错提示：
error:*** No rule to make target `include/config/auto.conf', needed by `include/config/uboot.release'.  Stop.
解决方法:
make distclea



第11章节 定时器和时间管理
	时间管理在内核中占有非常重要的地位。相对于事件驱动而言，内核中有大量的函数
	都是基于时间驱动的。其中有些函数是周期执行的，像对调度程序中运行队列进行平衡
	调整或对屏幕进行刷新这样的函数，都需要定期执行，比如说，每秒执行100次，而另
	外一些函数，比如需要推后执行的磁盘I/O操作，则需要等待一个相对时间后才运行
	比如说，内核还必须管理系统运行时间以及当前日期和时间。

	请注意相对时间和绝对时间之前的差别。如果某个事件在5s后被调度执行，那么系统
	所需要的不是绝对时间，而是相对时间（比如，相对现在起5s后）;相反，如果要求
	管理当前日期和当前时间，则内核不但要计算流逝的时间而且还要计算绝对时间。
	所以这两种时间概念对内核时间管理来说都至关重要的。

	另外，还请注意周期性产生的事件与内核调度程序推迟到某个确定执行的事件之间的
	差别。周期性产生的事件------比如第10ms一次-----都是由系统定时器驱动的。
	系统定时器是一种可编程硬件芯片，它能以固定频率产生中断。
	该中断就是所谓的定时器中断，它所对应的中断处理程序去负责更新系统时间，也负责
	执行需要周期性运行的任务。

	系统定时器和时钟中断处理程序是Linux系统内核管理机制中的中枢。

	本章关注的另外一个焦点是动态定时器----一种用来推迟执行程序的工具。
	比如说，如果软驱马达在一定时间内都未活动，那么软盘驱动程序会使用动态定时器来
	关闭软驱马达。内核可以动态创建或撤销动态定时器。本章将介绍动态定时器在内核中
	的实现，同时给出在内核中可供使用的定时器接口。


11.1 内核中的时间概念

	时间概念对计算机来说有些模糊，事实上内核必须在硬件的帮助下才可能计算和管理时间。
	硬件为内核提供了一个系统定时器用以计算流逝的时间，该时钟在内核中可看成一个电子
	时间资源，比如数字时钟或者处理器频率等。系统定时器以某种自行触发经常被称为击中
	或射中时钟中断，该频率可以通过编程预定，称作节拍率（tick
	tate）当时钟中断发生时，内核就通过一种特殊的中断处理程序对其进行处理。

	因为预编的节拍率对内核来说是可知的，所以内核知道连续两次时钟中断间隔时间。
	这个间隔时间就称为节拍(tick)它等待节拍率分之一秒(1/tick
			rate)秒。正如你所看到的，内核就是靠这种已知的时钟中断间隔来计算
	墙上时间和系统运行时间的。墙上时间(也就是实际时间)对用户的应用程序来说是最重要
	的。内核通过控制时钟中断维护时间,另外内核也为用户空间提供了一组系统调用以
	获取实际日期和实际时间。

	系统运行时间（自系统启动开始所经的时间）对用户空间和内核都很有用，因为许多程序都
	必须清楚流逝的时间。
	
	通过两次（现在和以后）读取运行时间再计算它们的差，就可以得到相对流逝的时间了。

	*时钟中断对于管理操作系统尤为重要，大量内核函数的生命周期都离不开流逝的时间的
	控制。

    *更新系统运行时间。
    *更新实际时间。
	*在smp系统上，均衡调度程序中各处理器的运行队列。如果运行队列负载不均衡的话。
	尽量使它们均衡。

	*检查当前进程是否用尽了自己的时间片。如果用尽，就重新进程调度
	*运行超时的动态定时器。
	*更新资源消耗和处理器时间的统计值。

	这其中有些工作在每次的时钟中断处理程序中都要被处理--也就是说，这些工作随时间频率
	反复运行。另一些也是周期性地执行，但只需要每n次时钟中断运行一次，也就是说,这些函数
	在累计了一定数量的时钟节拍时才被执行。在“定时器中断处理程序"这一小节中，我们将详细
	讨论时钟中断处理程序。



11.2 节拍率：HZ
	系统定时器（节拍率）是通过静态预留处理定义的，也就是HZ，在系统启动时按照HZ值对硬件
	进行设置。体系结构不同，HZ值也是不同，实际上，对于某些体系结构来说，甚至是机器不同
	它的值都会不一样。

		内核在<asm/param.h>文件中定义了这个值。节拍率有一个HZ频率，一个周期为1/HZ秒。
		例如，X86体系结构中，系统定时器默认值为100。因此，x86上时钟的频率就为100hz。
		也就是在i386处理器上的每秒中中断100次，10ms产生一次。
		其他体系结构的节拍率为250和1000，分别对应4ms和1ms。表11-1给出了各种体系结构
		与各自对应节拍率的完整列表。

	编写内核代码时，不要认为HZ值是一个固定不变的值。这不是一个常见的错误，因为大多数
	体系结构的节拍都是可调的。但是在过去，只有Appha这一种机型的节拍率不等于100，所以很
	多本该使用HZ的地方，都错误地在代码中直接硬编码成100这个值。稍后，我们会给出内核代码
	中使用HZ的例子。
		正如我们看到的，时钟中断能处理多内核任务，所以它对内核来说极为重要，事实上，内核
		中的全部时间概念都源于周期运行的系统时钟，所以选择一个合适的频率，就如同在人际
		交往中建立和和谐关系一样，必须取各方面的折中。


	 arm 100

11.2.1 理想的HZ值
	自Linux问世以来，i386体系结构中时钟中断频率设定为100HZ，但是在2.5开发板内核中，中断
	频率被提高到1000Hz，当然，是否应该提高频率（如同其他绝大多数事情一样）是饱受争议的。
	由于内核中众多子系统都必须依赖时间中断工作，所以改变中断频率必须会对整个系统造成
	很大的冲击。但是，任何事件总是有两面性的，我们接下来就来分析系统定时器使用高频率与
	使用低频率各有那些优劣。
	提高节拍意味着时钟中断产生得更加频繁，所以中断处理程序也会更加频繁地执行。
	如此一来会给整个系统带来如下好处。
	*更高的时钟中断解析度可提高时间驱动事件的解析度。
	*提高节拍率等同于提高中断解析度。比如HZ=100的时钟的执行粒度为10ms，即系统中周期事件最快
	为第10ms运行一次，而不可能有更高的精度，但是当HZ=1000时，解析度就为1ms-------精细了10倍。
	虽然内核可以提供频度为1ms的时钟，但是并没有证据显示对系统中所有程序而言，频率为1000Hz
	的时钟频率相对频率为100的时钟都很更合适。
		另外，提高解析度的同时也提高了准确度。假定内核在某个随机时刻触发定时器，而它可能在
		任何时间超时，但由于只有在时钟中断到来时才可能执行它，所以平均误差大约为半个时钟
	中断周期。比如说，如果时钟周期为HZ=100，那么事件平均在设定时刻+/-
	5ms内发生，所以平均误差为5ms，如果为Hz=1000，那么平均误差可降低到0.5ms----准确度提高了
	10倍。

11.2.2 高Hz的优势
	更高的时钟中断频度和更高的准确度又会带来如下优点：
	*内核定时器能够以更高的频度和更高的准确度（它带来了大量的好处，下一条便是其中之一）
	运行。
	*依赖定时值执行的系统调用，比如poll()和select(),能够以更高的精度运行。
	*对诸如资源消耗和系统运行时间等的测量会有理精细的解析度。
	*提高进程抢占的准确度。

	对poll()和select()超过精度的提高会系统性能带来极大的好处。提高精度可以大幅提高系统
	性能。频繁使用上述两种系统调用的应用程序，往往在等待时钟中断上浪费大量时间，而事实
	上，定时值可能早就超时了，回忆一下，平均误差（也就是，可能浪费时间），可是时钟中断
	周期的一半。

	更高的准备率也使用进程抢占更准确，同时还会加快调度响应时间。第4章提到过，时钟中中断
	处理程序负责减少当前进程的时间片计数。当时间片计数跌到0时，而又设置了need_resched标志
	的话，内核便立刻重新运行调度程序。假定有一个正在运行的进程，它的时间片只剩下2ms了，
	此时调度程序又要求抢占该进程，然后去运行另一个新进程：然而，该抢占行为不会在下一个
	时钟中断到来前发生，也就是说，在这2ms内不可能进行抢占。实际上对于频率为100HZ的时钟来说，
	最坏要在10ms扣才能执行。当然，进程之间也是平等的，因为所有的进程都是一视同仁的待遇，
	调度起来都不是很准确---------但关键不在于此，结果是无法接受的，如果将节拍率提高到
	1000HZ，在最坏情况下，也能将调度延误时间降低到1ms，而平均情况下，只能降到0.5ms左右。


11.2.3 高HZ的劣势
	现在谈谈另一面了，提高节拍率会产生副作用。事实上，把节拍提高到
	10000HZ会带来一个大问题：节拍率越高，意味着时钟中断频率越高，也就意味时钟中断越高，也就
	意味着系统负担越重。因为处理器必须花时间来执行中断处理程序，所以节拍率越高，中断处理
	程序占用的处理器的时间越多。这样不但减少了处理器时间，而且还会更频繁地打乱处理器高速
	缓存并增加耗电。负载造成的影响值得进一步探讨。将时钟频率从100HZ提高到1000HZ必然会使用
	时钟中断负载增加10倍。可是增加前的系统负载又是多少呢？
	最后的结论是：至少在现代计算机系统上，时钟频率为1000Hz不会导致难以接受的负担，并且不
	会对系统性能造成较大的.
	在2.6内核中还是允许编译内核时选定不同的HZ值。


无节拍的OS？也许你疑惑操作系统是否有固定时钟。尽管40年来，几乎所有的通过操作系统都使用与本章
描述的系统类似的时钟中断，但Linux内核支持”无节拍操作“这样的选项。当编译内核时设置了CONFIG_HZ
配置选项，系统就根据这个选项动态调度时钟中断。并不是每隔固定的时间间隔触发时钟中断，而是按需动态
动态调度和重新设置。如果下一个时钟频率设置为3ms，就每3ms触发一次时钟中断。之后，如果50ms内
都无事可做，内核以50ms重新调度时钟中断。
	减少开销总是受欢迎的，但是实质还是省电，特别是在系统空闲时。在基于节拍的标准系统中，即使用
在系统空闲期间，内核也需要为时钟中断提供服务。对于无节拍的系统而言，空闲档期不会被不必要的时钟
钟所打断，于是减少了系统的能耗。且不论空闲期是200ms还是200秒，随着时间的推移，所省的电是实实
在在的。


11.3 jiffiles
	全局变量jiffies用来记录自系统启动以来产生的节拍的总数。启动时，内核将变量初始化为0，此后
	每次时钟中断处理程序就会增加该变量的值。为1s内时钟中断的次数等于HZ，所以jifflies一秒内
	增加的值也就是Hz系统运行时间是以秒为单位计算，就等于jiffies/HZ实际出现的情况可能稍微复杂
	些：内核给jiffies赋一个特殊的初值。引起这个变量不断的溢出，由此捕捉bug。当找到实际的jiffies
	值后，就首先把这个”偏差“减去。

	jiffies定义于文件<Linux/jiffies.h>
	jiffies类型为无符号长整型(unsigned long)用其他任何类型存放它都不正确



11.3.1 jiffies的内部表示
 unsinged long
	
 32位的jiffies变量，在时钟频率为100HZ的情况下，497天后会溢出。如果频率为1000Hz 49.7
 天就会流出。而如果使用63位的jiffies变量。任何人都另指望会看到它溢出。

 由于性能与历史的原因，主要还考虑到与现有内核代码的兼容性,内核开发都希望jiffie依然为
 unsignedunsigned long.有一些巧妙的思想和少数神奇的链接程序扭转了这一局面。


11.3.2 jiffies的回绕
	和任何C整型一样，当jiffies变量的值超过它的最大存放范围后就会发生溢出。对于32位无符号
	长整型，最大取值为2^32-1。所以在溢出前定时器节拍计数最大为4294967295。
	如果节拍计数达到了最大值还要继续增加的话，它的值会回绕到时0。


	unsinged long timeout = jiffies + HZ/2; /* 0.5秒后超时 */

	/* 然后查看是否花的时间过长 */
	if (timeout > jiffies) {
			/* 没有超时 */
	}else{
		    /* 超时了，发生错误 */
	}
	
	上面这一小段代码是希望设置一个准确的超时时间---本例中从现在开始计时，时间为半秒。
	然后再去处理一些工作，比如探测硬件然后等待它响应。如果处理这些工作的时间超过了设
	定的超时赶时间，代码就要做出相应的出错处理。
	这里有很多种发生溢出的可能，我们只分析其中之一：考虑如果在


	



	













	

	

