第4章 进程调度
	第3章讨论了进程，它在操作系统来看是运行态表现形式。本章将讨论
	进程调度程序，它是确保进程能有效工作的一个内核子系统。
	调度程序负责决定将哪个进程投入运行，何时运行及运行多长时间。进程
	调度程序(常常简称调度程序),可看做在可运行态进程之间分配有限的处理
	器时间资源的内核子系统。

	调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的
	合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。

	调度程序没有太复杂的原理。最大限度地利用处理器时间的原则是，只要有可以
	执行的进程，那么就总会有进程正在执行。但是只要系统中可运行的进程数目比
	处理器的个数多，就注定某一给定时刻有一些进程不能执行。这些进程等待运行。

	在一组处于可运行状态的进程中选择一个来执行，是调度程序所需要的基本工作。


4.1 多任务
	多任务操作系统就是能同时并发地交互执行多个进程的操作系统。在单处理机器
	上，这会产生多个进程同时运行的幻觉。
	在处理器机器上，这会使多个进程在不同的处理器上真正同时，并行地运行。

	无论在单处理器或者多处理器机器上，多任务操作系统都能使多个进程处于堵塞
	或者睡眠状态，也就是说，实现上不被投入执行，直到工作就就绪。这些任务尽
	管位于内存，但并不处于可运行状态。相反，这些进程利用内核阻塞自己，直到
	某一事件(键盘输入，网络数据，过一段时间等)发生。因此，现代Linux系统也许
	有100个进程在内存，但是只有一个处于可运行状态。

		多任务系统可以划分为两类：非抢占式多任务(cooperative multitasking)
	和抢占式多任务(preemptive multitasking)。像所有Unix的变体和许多其他现代
	操作系统一样，Linux提供了抢占式的多任务模式。在此模式下，由调度程序来
	决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这个强制
	挂起动作就叫抢占。()

	进程在被抢占之前能够运行的时间是预先设置好的，而且有一个专门的名字，叫进
	程的时间片(timeslice)。时间片实际上就是分配给每个可运行进程的处理器时间段。

		有效管理时间片能使调度程序从系统全局的角度做出调度决定，这样做还可以
	避免个别进程独占系统资源。
	
	当今众多现代操作系统对程序运行都采用了动态时间
	片计算的方式，并且引入了可配置的计算策略。不过我们将看到，Linux独一无二的
	“公平”调度程序本身并没有采取时间片来达到公平调度。

		相反，在非抢占式多任务模式下，除非进程自己主动停止运行，否则它会一直
	执行。进程主动挂起自己的操作称为让步。
	理想情况下，进程通常做出让步，以便
	让每个可运行进程享有足够的处理器时间，但这种机制有很多缺点：
		调度程序无法对每个进程执行多长时间做出统一规定，所以进程独占处理器的
	时间可能超出用户的预料：更糟的是，一个决不做出让步的悬挂进程就可能使用
	系统崩溃,Unix从一开始就是采用抢先式的多任务。

4.2 Linux的进程调度
		从1991年Linux的第1版到后来的2.4内核系统，Linux调度程序都相当简陋，
		设计近乎原始。当然它很容易理解。

	在Linux2.5开发系列中，调度程序做了大手术，开始采用一种叫做O(1)调度程序
	的新调度程序--------它因为其算法的行为而得名。它解决了先前版本Linux调度
	程序的许多不足，引入了许多强大的新特性和性能特性。
	这里主要感谢静态时间片算法和针对每一处理器的运行队列，它帮助我们摆脱了先
	前调度程序设计上的限制。
	(O(1),用的是最大o表示法，简而言之，它是指不管输入有多大，调度程序都可以
	在恒定时间内完成工作。第6章是一份完整的大O表示法说明。)
	

	O(1)调度器虽然拥有数以十计(不是数以百计)的多处理器环境下尚能表现了近乎
	完美的性能和可扩展性，但是时间证明该调度算法对于调度那些响应时间敏感的
	程序去有一些先天不足。这些进程我们称之为交互进程---它无疑包括了所有
	需要用户交互的程序。正因为如此，O(1)调度程序虽然对于在服务器工作负载
	很理解，但是在有很多交互程序要运行的桌面系统上表现不佳，因为其缺少交互
	进程。

	自2.6内核系统开发初期，开发人员为了提高对交互程序的调度性能引入了新的进程
	调度算法。其中最为著名的是“反转楼梯最后期限调度算法(RSDL),该算法吸取了队
	列理论，将公平调度的概念引入Linux调度程序。并在2.6.23内核版本中替代了O(1)
	调度算法，它此刻被称为完美公平调度算法，或者简称CFS。
		本章将会讲解调度程序设计的基础和完全公平调度程序如何运用，如何设计，
		如何实现以及与它相关的系统调用，四个方面我们当然也会讲解O(1)调度程序
		，因为它毕竟是经典Unix调度程序模型的实现方式。

4.3 策略
		策略决定调度程序在何时让什么进程运行。高度器的策略往往就决定系统的
		整体印象，并且，还要负责优化使用处理器的时间。无论从哪个方面来看，
		它都是至关重要的。
	
4.3.1 I/O消耗型和处理器消耗型的进程
	进程可以被分为I/O消耗型处理和处理器消耗型。前者指进程的大部分时间用来提交
	I/O请求或是等待I/O请求。因此，这样的进程经常处于可运行状态，但通常是运行
	短短一会儿，因为它在等待更多的I/O请求时，最后总会阻塞（这里所说的I/O是指
	任何类型的可阻塞资源，比如键盘输入，或者是网络I/O）。举例来说，多数用户
	图形界面程序(GUI)都属于I/O密集型，即使它们从不读取或者写入磁盘。它们也会
	在多数时间里都在等待来自鼠标或者键盘的用户交互操作。

	相反，处理器耗费进程把时间大多用在执行代码上。除非被抢占，否则它们通常
	都一直不停地运行，因为它们没有太多的I/O需求。但是，因为它们不属于I/O驱动
	类型，所以从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器
	消耗的进程，调度策略往往是尽量降低它们的调度频率，而延长其运行时间。处理
	器消耗型进程的极端例子就是无限循环地执行。更具代表性的例子是那些执行大量
	数学计算的例子，如sshkeygen 或者MATLAB。

	当然这种划分方法并非绝对的，进程可以同时展示这两种行为：比如，X
	Window服务器既是I/O消耗型，也是处理器消耗型。还有些进程可以是I/O消耗型
	但属于处理器消耗型活动的范围。
	其典型就是字处理器，其通常坐以等待键盘输入，但在任一时刻可能又粘住处理器
	进行疯狂地进行拼写检查或者宏计算。



		调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速和最大系统
	利用率(高吞吐量)。为了满足上述的需求，调度程序通常采用一套复杂的算法来
	决定最值得运行的进程投入运行，但是不保证低优先级进程会被公平对待。

	Unix系统的调度程序更倾向于I/O消耗型程序，以提供更好的程序响应速度。
	Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化(缩短了)
	响应时间，更倾向于优先调用I/O消耗型


4.3.2 进程优先级
	调度算法中最基本的一类就是基于优先级的调度。这是一种根据进程的价值和其
	对处理器时间的需求来对进程分级的想法。
	通常做法是(并没有被Linux系统完全采用)优先级高的进程先运行，低的后运行，
	相同优先级的进程按轮转方式进行调度(一个接一个，重复进行).在某些系统中
	优先级高的进程使用的时间片也较长。调度程序总是选择时间片未用尽而且优先
	级最高的进程运行。用户和系统都可以通过设置进程的优先级来影响系统的调度。

		Linux采用了两种不同的优先级范围。第一个是用nice值，它的范围是从-20
		到+19，默认值为0;越大的nice值意味着更低的优先级。nice似乎意味着你
	对系统中其他进程更"优待”。
	相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的
	处理器时间。nice值是所有Unix系统中标准化的概念，但不同的Unix系统由于调度
	算法不同，因此nice值的运用方式有所差异。

	第二种范围是实时优先级的调度。其值是可以配置的，默认情况下它的变化范围是
	0-99(包括0和99)。与nice值意义相反，越高的实时优先级和nice优先级处于互不相
	交的两个范畴。Linux实时优先级的实现参考了Unix相关标准----特别是Posix.1b.
	你可以通过命令：
	ps -eo state,uid,pid,ppid,rtprio,time,comm
	查看到你系统中的进程列表，以及它们对应的实时优先级(位于RTPRIO列下)，其中
	如果有进程对应列显示 “-"则说明它不是实现进程。

4.3.3 时间片
(简单来说就是CPU分配给各个程序的时间，使各个程序表面上看是同时进行的，而
不会造成CPU资源浪费)

	(在其他系统中，时间片有时也称为量子或处理器片。但Linux把它叫做时间片)
	时间片是一个数值，它表明进程被抢占前所能持续运行的时间。调度策略必须
	规定一个默认的时间片，但这不是件简单的事。时间片过长会导致系统对交互的
	响应表现欠佳，让人觉得系统无法并发执行应用程序。
	时间片太短会明显增加进程切换带来的处理器耗时，因为肯定会有一部分系统时间
	用在进程切换上，而这些进程能够用来运行的时间片却很短。
	此外，I/O消耗型和处理器消耗型的进程之间的矛盾在这里也再次显露出来
	I/O消耗型不需要长的时间片，而处理器消耗型的进程希望越长越好
	(比如这样可以让它们的高速缓存命中率更高)

	从上面争论看出：长时间片都将导致系统交互表现欠佳。很多操作系统中都特别
	重视这一点，所以默认的赶时间片很短，如10ms。但是Linux的CFS调度器并没有
	直接分配时间片到进程，它是将处理器的使用比划分给了进程，这样一来，进程
	所获得的处理器时间其实是和系统负载密切相关的。
	
	
	这个比例进一步还会受到nice
	值的影响，nice值作为 权重将调整进程所使用的处理器时间使用比，而小nice值
	的进程会被赋予高权重，从而枪得更多的处理器时间

	像前面说的，Linux系统是枪占式的。当一个进程进入可运行态，它就被允许
	投入运行，在多数操作系统中，是否要将一个进程立即投入运行（也就是
	抢占当前进程），是完全由进程优先级和是否有时间片决定的。而在Linux
	中使用新的CFS调度器，其抢占时间取决于新的可运行程序消耗了多少处理器
	使用比。
	
	如果是消耗的使用比比当前进小，则新进程立刻投入运行，抢占当前
	进程，否则推迟其运行。

4.3.4 调度策略的活动
	想象下面这样一个系统，拥有两个可以运行的进程：一个文字编译和一个视频编码
	程序。

	文字编辑是i/o消耗型，视频处理是处理器消耗型。

	在这样的场景中，理想情况是调度器应该给予文本比视频更多的处理时间。
	对于文本编辑器，我们有两个目标。
	第一是我们要更多的时间是因为我们希望在它需要时能得到处理器
	第二我们希望文本编辑器能在其被唤醒时抢占视频解码程序。
	这样才能确保文本编辑器具有很好的交互性能。
	在多数操作系统中，上述目标的达成是要依靠系统分配给文本编辑器比视频解码程序
	更高的优先级和更多的时间片。

	先进的操作系统可以自动发现文本编辑器是交互程序，从而自动地完成上述分配动作。
	Linux操作系统同样需要追求上述目标，但是它采用不同方法。它不通过给文本编辑器
	分配给定的优先级和时间片。而是分配一个处理器使用比。

	假如文本和视频解码是仅有运行的两个进程，并且又具有同样的nice值。那么处理器的
	使用比将都是50%--------它们平分了处理器时间
	但因为文本编辑器将更多的时间用于等待用户输入，因此它肯定不会用到处理器的50%。???
	同时，解码程序无疑将有机会超过50%的处理器时间。

	这里的关键问题是，当文本编辑器程序被唤醒时，将发生什么。我们首要目标是确保其
	能在用户输入发生时立刻运行。在上述场景中，一旦文本编辑被唤醒，CFS注意到给它的
	处理器使用比是50%，但是其实它却用得少之又少。特别是，CFS发现文本编辑器比视频
	短得多，这种情况下为了兑现让所有进程能公平分享处理器的，它会立刻抢占视频解码
	程序，让文本编辑器投入运行。文本文本编辑器运行后立即处理了用户的键入。又一次
	进入睡眠等待用户下一次输入。因为文本编辑器并没有消费掉承诺给它的50%处理器
	使用比。因此情况依旧。





