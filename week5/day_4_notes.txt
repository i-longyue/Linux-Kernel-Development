第14章 块I/O层
	系统中能够随机(不需要按顺序)访问固定大小数据片的硬件设备称作块设备,这些固定大小的数据片就称作块.
	最常见的块设备是硬盘.软盘,闪存.
	注意:它们都是以安装文件系统的方式使用的--这也是块设备一般的访问方式.

	另一种基本的设备类型是字符设备.字符设备是按照字符流的方式被有序访问,像串口和键盘就属于字符
	设备.如果一个硬件设备是以字符流的方式被访问的话.那就该将它归于字符设备;反过来,如果一个设备
	是随机访问的,那么它就属于字符设备;反过来,如果一个设备是随机无序访问的,那么它就属于块设备

	对于这两种类型的设备,它们的区别在于是否可以随机访问数据---也就是能否在访问时随意地从一个
	位置跳转到另一个位置.
	键盘就是一个典型的字符设备,它提供的就是用户从键盘输入的字符地流.对键盘进行读操作会得到一个
	字符流,首先是w,然后是o,再是l,最后是x.当没人敲键盘时,字符流就是空的.

	硬盘设备的情况就大不一样了.硬盘设备的驱动可能要求读取磁盘上任意块的内容,然后又转去读取别的块
	的内容,而读取的块在磁盘的位置不一定要连续,所以说硬盘数据的数据可以被随机访问.而不是以流的方式
	被访问,因此它是一个块设备.

		内核管理块设备要比管理字符设备细致得多,需要考虑的问题和完成工作相对于字符设备来说复杂许多.
	这是因为字符设备仅仅需要控制一个位置--当前位置,而块设备访问的位置必须能够在介质的不同区间移动
	.所以事实上内核不必提供一个专门的子系统来管理字符设备,但是对块设备的管理却必须要有一个专门
	提供服务的子系统.不仅仅是因为块设备的复杂性远远高于字符设备.更重要的原因是块设备对执行性能要求
	很高:对硬盘每多一份利用都会对整个系统的性能带来提升,其效果要远远比键盘吞吐速度成倍的提高大得多
	块设备的复杂性为这种优化留下很大的空间.
	这一章的主题就是讨论内核如何对块设备和块设备请求进行管理.该部分在内核中称作块I/O层,有趣的是,
	改写I/O层正是2.5开发版内核的主要目标.

14.1 剖析一个块设备
	块设备中最小的可寻址单元是扇区.扇区大小一般是2的整数倍.而最常见的是512字节.扇区的大小是设备
	的物理属性,扇区是所有块设备的基本单元--块设备无法对比它还小的单元进行寻址.
	
	因为各种软件的用途不同,所以它们都会用到自己最小逻辑可寻址单元----块.
	块是文件系统的一种抽象----只能基于块来访问文件系统.\
	块不能比扇区小,只能数倍于扇区大小.另外,内核还要求块大小是2的整数倍,而且不能超过一个页的长度.
	所以块大小的最终要求是,必须是扇区大小的2的整数倍,并且要小于页面大小.所以通常块大小是512字节,
	1KB或4KB.

	扇区和块还有一些不同的叫法,为了不引起混淆,我们在这里简要介绍一下它们的其他名称.
	扇区设备的最小寻址单元,有时会称作"硬扇区"或"设备块"同样的,块---文件系统的最小寻址单元,
	有时会称作"文件块"或"I/O块".在这一章里,会一直使用"扇区"和"块"这两个术语,但是你也要记住它们
	这些别名.


	至少相对于硬盘而言,大多数情况下,对用户空间的软件是不可见的.扇区这一术语之所以对内核重要,是因
	为所有的设备I/O必须以扇区为单位进行操作.以此类推.内核所使用的"块"这一高级概念就是建立在扇区之
	上的.


14.2 缓冲区和缓冲区头
	当一个块被调用调入内存时,它要存储在一个缓冲区中.每个缓冲区与一个块对应,它相当于磁盘块在内存中的
	表示.
	由于内核在处理数据时需要一些相关的控制信息(比如块属于哪个块设备,块对应哪个缓冲区等),所以每一个
	缓冲区都有一个对应的描述符.该描述符用buffer_head结构体表示,称作缓冲区头,在文件linux/buffer_head.h
	中定义,它包含了内核操作缓冲区所需要的全部信息.

	下面给出缓冲区头结构体和其中各个域的说明:
	struct buffer_head{
			unsi
				..
				..
	}

	b_state域表示缓冲区的状态,可以是表14-1中一种或多种标志的组合.合法的标志存放在bh_state_bits枚举中,
	该枚举在<linux/buffer_head.h中定义.

	b_state_bits列表还包含了一个特殊标志----BH_PrivateStart,该标志不是可用状态标志,使用它是为了指明
	可被其他代码使用的起始位.块I/O层不会使用BH_PrivateStart或更高的位

	b_count域表示缓冲区的使用记数,可通过两个定义在文件linux/buffer_head.h中的内联函数对此域进行增减.

	get_bh()函数
	put_bh()

	在操作缓冲区头之前使用get_bh()函数增加缓冲区头的引用计数,确保缓冲区头不会再被分配出去;
	当完成对缓冲区头的操作之后,还必须使用put_bh()函数减少引用计数.

	与缓冲区对应的磁盘块由b_blocknr-th域索引,该值是b_bdev域指明的块设备中的逻辑块号

	与缓冲区对应的内存物理页由b_page域表示,另外,b_data域直接指向相应的块,块的大小由b_size,域表示,
	所以块在内存中的起始位置在b_data处,结束位置在(b_data + b_size)处.

	缓冲区的目的在于描述磁盘块和物理内存缓冲区之间的映射关系.这个结构体在内核中只扮演一个描述符
	的角色,说明从缓冲区到块映射关系.

	在2.6内核以前,缓冲区头作为内核中I/O操作单元,不仅仅描述了从磁盘致到物理内存的映射,而且还是
	所有块I/O操作的容器.可是,将缓冲区头作为I/O操作单元带来了两个㢢端.首先,缓冲区头是一个很大且
	不易控制的数据结构体,而且缓冲区头对数据的操作既不方便也不清晰.


	在2.6版本中操作都是通过内核直接对页面或地址空间进行操作来完成,不再使用缓冲区头了.
	这其中所做的一些工作会在第16章进行讨论.具体情况参考address_space结构和pdflush等守护进程部分.

	缓冲区头带来了第二个㢢端是:它仅仅能描述单个缓冲区,当使用所有I/O的容器使用时,缓冲区头会促使
	内核把对大块数据的I/O操作(比如写操作)分解为多个buffer_head结构体进行操作


14.3 bio结构体
	目前内核中块I/O操作的基本容器由bio结构体表示,它定义在文件bio.h中,该结构体代表了正在现场的
	以片断链表形式组织的块I/O操作

	一个片段是一小块连续的内存缓冲区.这样的话,就不需要保证单个缓冲一定要连续.所以通过用片段来描述
	缓冲区.即使一个缓冲区分散在内存的多个位置上,bio结构体也能地内核保证I/O操作的执行.像这样的
	向量I/O就是所谓的聚散I/O
	struct bio {

	}

	使用bio结构体的目的主要是代表正在现场执行的I/O操作,所以该结构体中主要域都是用来管理相关信息的,
	其中最重要的几个域就是bi_io_vecs,bi_vcnt和bi_idx图14-2显示了bio结构体及其他结构体之间的关系.

	struct bio
	bi_io_vec              bi_idx

	bio_vec bio_vec  bio_vec bio_vec  bio_vec结构体链表,总数为bio_vent
	 
	页面
		页面
			页面
				页面



14.3.1 I/O  向量
	bi_io_vec域指向一个bio_vec结构体数组,该结构体链表包含了一个特定I/O操作需要使用到
	的所有片段.每个bio_vec结构都是一个形式为Page ,offset ,len的向量,它描述的是一个
	特定的片段:片段所在的物理页,块在物理页中偏移位置,从给定偏移量开始的块长度.
	整个bio_io_vec结构体数组表示了一个完整的缓冲区.bio_vec结构定义在linux/bio.h 中
	struct vio_vec{
	}
	在每个给定的块I/O操作中,bi_vcnt域用来描述bi_io_vec所指向的vio_vec数据中的向量
	当块I/O执行完毕后,bi_idx域指向数组的当前索引.

	总而言之,每一个块I/O请求都通过一个bio结构体表示,每个请求包含一个或者多个块,这
	些块存储在bio_vec结构体数组中,这些结构体描述了每个片段在物理页的实际位置,并且
	像向量一样被组织在一起.

	bi_cnt域记录bio结构体的使用计数,如果该值减为0,就应该撤销bio结构体,并释放它占用
	的内存.通过下面两个函数管理使用计数.
	void bio_get(struct bio *bio);
	void bio_put(struct bio *bio);
	前者增加使用计数,后者减少使用计数,如果计数减到0,则撤销bio结构体.在操作正在活动的bio
	结构体时,一定要首先增加它的使用计数,以免在操作过程中该bio结构体被释放,相反,在操作
	完毕后,要减少使用计数.
	最后要说明的是bi_private域,这是一个属于拥有者的私有域,只有创建了biox结构的拥有都
	可以读写该域.

14.3.2 新老方法对比
	缓冲区头和新的bio结构体之间在此显蓍差别.bio结构代表代表的是I/O操作,它可以包括内存
	中的一个或多个页,而另一方面,buffer_head结构体代表的是一个缓冲区,它描述仅仅是磁盘
	中的一个块.
	由于bio结构体是轻量级的,它描述的块可以不需要连续存储区,并且不需要分割I/O操作.
	利用bio结构体代替buffer_head结构体还有以下好处:
	*bio结构体很容易处理高端内存,因为它处理的物理页而不是直接指针.
	*bio结构体既可以代表变通页I/O,同时也可以代表直接I/O
	(指那些不通过页高速缓存的I/O操作)
	*bio结构体便于执行分散-集中
	*bio结构体相比缓存区头属于轻量化结构体.

	但是还是需要缓冲区头这个概念,毕竟它还负责描述磁盘块到页面的映射.bio结构体
	不包含任何和缓冲区相关的状态信息


14.4 请求队列
	块设备将它们挂起块的I/O请求保存在请求队列中,该队列由reques_queue结构体表示,定义在文件
	linux/blkdev.h中,包含一个双向请求链表以及相关控制信息.通过内核中像文件系统这样高层的
	代码将请求加入到队列中,请求队列只要不主空,队列对应的块设备驱动程序就会从队列头获取请求
	然后将其送入对应块设备上去.请求队列中每一项都是一个单独的请求,由reques结构体表示.

		队列中的请求由结构体request表示,它定义在文件<linux/blkdev.h>中.因为一个请求可能
	要操作多个连续的磁盘块,所以每个请求可以由多个bio结构体组成.注意,虽然磁盘上的块必须
	连续,但是在内存中这些块并不一定连续----每个bio结构体都可以描述多个片段,而每个请求
	也可以包含多个bio结构体.

14.5 I/O 调度程序
	如果简单以内核产生请求的次序直接将请求发生块设备的话,性能肯定让人难以接受.
	磁盘寻址是整个计算机中最慢的操作之一,第一次寻址需要花费不少时间,所以尽量缩短寻址时间无疑是
	提高系统性能的关键.

	为了优化寻址操作,内核既不会简单地按请求接收次序,也不会立即将其提交磁盘.相反,它会在提交前,先执行
	名为合并与排序的操作,这种操作可以极大地提高系统的整体性能.
	
	在内核中负责提交I/O请求的子系统称为I/O调度程序.
	I/O调度程序将磁盘I/O资源分配给系统中所有挂起来的块I/O请求.具体地说,这种资源分配是通过将请求队列
	中挂起的的请求合并和排序来完成的.注意不要将I/O调度程序和进程调度程序混淆.进程调度程序的作用
	是将处理器资源分配给系统中运行进程.这两种子系统看起来非常相似,但并不相同.

	I/O调度程序虚拟块设备给多个磁盘请求,以便降低磁盘寻址时间,确保磁盘性能的最优化.
	
14.5.1 I/O调度程序的工作
	I/O调度程序的工作是管理块设备的请求队列.它决定队列中请求排列顺序以及在什么时候派发请求到块设备.
	这样做有利于减少磁盘寻址时间,从而提高全局吞吐量
	一个I/O调度器可能为了提高系统整体性能而对某些请求不公.

	I/O调度程序通过两种方法减少磁盘寻址时间:合并与排序.
	合并指将两个或多个请求结合成一个新请求.考虑一下这种情况,文件系统提交请求到请求队列----从文件中
	读取一个数据区,如果这时队列中已经存在一个请求.它访问的磁盘扇区和当前请求访问的磁盘扇区相邻,那么
	这两个请求将多次请求的开销压缩成一次请求的开销.
	更重要的是,请求合并后只需要传递给磁盘一条寻址命令,就可以访问到请求合并前必须多次寻址才能访问完
	的磁盘域

	现在,假设在读请求被提交给请求队列的时候,队列中并不需要操作相邻扇区的其他请求,此时就无法将当前
	请求与其他请求合并.当然,可以将其插入请求队列的尾部.但是如果有其他请求需要操作磁盘上类似的位置
	,如果存在一个请求,它要操作的磁盘扇区的排列顺序有序排列的目的不仅是为了缩短单独一次请求的寻址时间,
	更加重要的是,通过保持磁盘头以直线方向移动,缩短了所有请求的磁盘寻址时间.该排序算法类似于电梯调度

14.5.2 Linus电梯,下面看看Linux中实际使用的I/O调度程序.我们看到的第一个I/O调度程序称为Linus电梯,
	在2.4版内核中,Linux电梯是默认的I/O调度程序.
	在2.6版内核中它被另外两种调度程序取代了.

	Linus电梯能执行合并与排序处理.当有新的请求加入队列时,它首先会检查其他第一个挂起的请求是
	否可以和新请求合并.linus电梯I/O调度程序可以执行向前和向后合并,合并类型描述的是向前还是向
	后面,这一点和已有请求相连,如果新请求正好连接在一个现存的请求前,就是向前合并:相反如果新
	请求直接连在一个现存的请求后,就是向后合并.
	
	如果合并尝试失败,那么就需要寻找可能的插入点,如果找到,新请求将被插入到该点:如果没有合适
	的位置,那么新请求就被加入到尾部.另外,如果发现队列有驻留时间过长的请求.
	总而言之,当一个请求加入到队列中时,有可能发生四种操作:它们依次是:
	1)如果队列中已存在一个对相邻磁盘扇区操作的请求.那么新请求将和这个已经存在的请求合成一个
	请求.

	2)如果队列中存在一个驻留时间过长的请求,那么新请求将被插入到队列尾部.以防止其他旧的请求
	饥饿发生.
	
	3)如果队列中已存以扇区方向为序在合适的插入位置,
	4)如果队列中不存在合适的请求插入位置,请求将被插入到队列尾部.

14.5.3 最终期限I/O调度程序

	最终期限I/O调度程序是为了解决linus电梯所带来饥饿问题而提出的.
	因此2.6版本内核新引入了最后期限I/O调度程序来减少请求饥饿现象,特别是读请求饥饿现象.

	注意,减少请求饥饿必须以降低全局吞吐量为代价.
	在最后期限I/O调度程序中,每个请求都有一个超时时间,默认情况下,读请求超时时间是500ms,写
	请求的超时时间是5s.

	如果在写FIFO队列头,或是在读FIFO队列头请求超时(也就是,当前时间超过了请求指定的超时时间)
	那么最后期限I/O调度程序便从FIFO队列中提取请求进行服务.

	注意,最后期限I/O调度算法并不能严格保证请求的响应时间,但是通常情况下,可以在请求超时前
	提交和执行,以防止请求饥饿现象的发生.由于读请求给定的超时时间要比写请求短许多,所以最后
	最后期限I/O调度器也确保了写请求不会因为堵塞读请求而使读请求发生饥饿.这种对读操作的照顾
	确保了读响应时间尽可能短.
	
14.5.4 预测(cb)I/O调度算法 
	虽然最后期限I/O调度程序为降低读操作响应时间做了许多工作,但是它同时也降低了系统的吞吐量.

	预测I/O的基础仍然是最后期限I/O调度程序.

	预测I/O调度试图减少在进行I/O操作期间,处理新到的读请求所带来的寻址数量.

	要注意,如果等待可以减少读请求所带来的向后向前寻址操作,那么完全值得花一些时间来等待更多
	的请求.

	当然,如果没有I/O请求在等待期到来,那么预测I/O调度程序会给系统性能带来轻微的损失,浪费几ms.

	预测I/O调度程序的实现block/as-iosched.c它是linux内核中缺省的I/O调度程序,对大多数工作负荷
	来说都执行良好,对服务器也是理想的.

14.5.5 完全公正的排除I/O调度程序
	完全公正的排队I/O调度程序(Complete Fair Queuing, CFQ)是为专有工作负荷设计的,不过,在实际中
	,也为多种工作负荷提供了良好的性能
	完全公正的排队I/O调度程序位于block/cfq-iosched.c,尽管这主要推荐给桌面工作负荷使用,但是,
	如果没有其他异常情况,它在几乎所有的工作负荷中都能很好地执行.

14.5.6 空操作的I/O调度程序
	第四种也是最后一种I/O调度程序是空操作I/O调度程序,之所以这样命名是因为它基本上是一个空
	操作.

14.5.7  I/O调度程序的选择
	你现在已经看到2.6内核中四种不同的I/O调度程序.其中的每一种I/O调度程序都可以被启用,并
	内置在内核中,作为默认.
	*块设备使用完全公平的I/O调度程序.在启动时,可以通过命令选项elevator = foo来覆盖
	参数                 I/O调度程序
	as                   预测
	cfq                  完全公正的排队
	deadline             最终期限
	noop                 空操作
	例如,内核命令行选项elevator  = as会启用预测I/O调度程序所给所有的块设备,从而覆盖完
	公正调度程序.
	
14.6 小结
	在本章中,我们讨论了块设备的基本知识,并考察了块I/O层所用的数据结构:bio表示活动的I/O操作
	buffer_head,表示块到页的映射;还有请求结构,表示具体的I/O请求.我们追求了I/O请求简单但重要的
	生命历程,其生命的重要点就是I/O调度程序,我们讨论了I/O调度程序所涉及的困惑问题,同时仔细
	推敲了当前内核的4种I/O调度程序,以及2.4版本中原有的Linus电梯调度.
	我们将在第15章讨论进程地址空间























