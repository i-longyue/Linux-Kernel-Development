第13章 虚拟文件系统
1.linux内核简介
2.从linux内核出发
3.进程管理
4.进程调度
5.系统调用
6.内核数据结构
7.中断和中断处理程序
8.中断下半部及推进
9.同步概念
10.同步方法
11.时间和定时器
12.内存管理
13.虚拟文件系统

作为内核子系统为用户空间程序提供了文件和文件系统相关的接口.系统中所有文件系统不但系统VFS
共存,而且也依靠VFS系统协同工作,通过虚拟文件系统,程序可以利用标准的Unix系统调用对不同的文件
甚至不同介质上的文件系统进行读写操作.

ext3          VFS     <----->cp(1)
ext2


13.1 通用文件系统接口
	VFS使得用户可以直接使用open(),read()和write()这样的系统调用而无须考虑具体文件系统和实际物理
	介质.
	更了不起的是,系统调用可以在这些不同的文件系统和介质之间执行
	我们可以使用标准的系统调用从一个文件系统拷贝或移动数据到另一个文件系统.
	正是由于现代操作系统引入抽象层,比如Linux通过虚拟接口访问文件系统,才使得这种协作性和泛
	型存取成为可能.

	新的文件系统和新类型的存储介质都能找到进入Linux之路,程序无需重写,甚至无须重新编译.
	在本章中,我们将讨论VFS它把各种各样的存储设备--从cd到蓝光光盘,从硬件设备到闪存.


	VFS与块I/O相结合,提供抽象,接口以及交融,使得用户空间的程序调用统一的系统调用访问各种文件,
	不管文件系统是什么,也不管文件系统位于何种介质,采用的命令策略是统一的

13.2 文件系统抽象层
	之所以可以使用这样的通用接口对所有类型的文件系统进行操作,是因为内核在它的底层文件系统接口
	上建立了一个抽象层.
	为了支持多文件系统,VFS提供了一个通用文件系统模型,该模型包括了任何文件系统的常用功能集和行为.
	当然该模型偏重于Unix风格的文件系统.介即使这样,Linux仍然可以支持很多差异很大的文件系统.

	VFS抽象层之所以能衔接各种各样的文件系统,是因为它定义了所有文件系统都支持的,基本的,概念上的
	接口和数据结构.同时实际文件系统也将自身的诸如"如何打开文件","目录是什么"等概念在形式上与VFS
	保持一致.因为实际系统的代码在统一的接口和数据结构下隐藏了具体的实现细节,所以在VFS层和内核
	其他部分看来,所有文件系统都是相同的.

	内核通过抽象层能够方便,简单地支持各种类型的文件系统.实际文件和系统通过编程提供VFS所期望的抽象
	接口和数据结构,也可以和任何的文件系统无缝地连接在一起,完成了实际工作和.

	比如一个简单的用户空间程序执行如下操作
	ret = write(fd,buf,len);
		
	该系统调用将buf指针指向的长度为len的字节数据写入文件描述符fd对应的文件的当前位置.
	这个系统调用首先被一个通用系统调用sys_write()处理,sys_write()函数要找到fd所在的文件
	系统实际给出的是哪个写操作和,然后再执行该操作.

	实际文件系统的写方法是文件实现的一部分,数据最终通过这个操作写入介质
	用户空间    VFS     文件系统   物理介质


13.3 Unix文件系统
	unix使用了四种和文件系统相关的传统抽象概念:文件,目录项,,索引节点和安装点(mount point)
	从本质文件系统是:
	特殊的数据分层存储结构,它包含文件,目录和相关控制信息.
	文件系统通过操作包含创建,删除,和安装.
	在Unix中,文件系统被安装在一个特定的安装点上,该安装点在全局层次结构中被称作命名空间.所有的已
	安装文件系统都作为根文件系统树的枝叶出现在系统中.

	文件其实可以做一个有序字节串,字节串第一个字节是文件的头,最后一个字节是文件的尾.
	每一个文件为了便于系统和用户识别分配了一个便于理解的名字.典型的文件操作有读,写,创建,删除
	等,unix文件的概念与面向记录的文件系统形成鲜明的对照.

	文件通过目录组织起来,文件目录好比一个文件夹,用来容纳相关文件.
	因为目录可以包含其他目录,即了目录,所以目录可以层层嵌套,形成文件路径.
	路径中每一部分都被称作目录条目"/home/wolfman/butter"
	把它们通称为目录项.在Unix中目录属于普通文件,它列出包含在其中的所有文件.
	由于VFS把目录当作文件对待,所以可以对目录执行和文件相同的操作

	Unix系统将文件和相关信息和文件本身这两个概念加以区分,例如访问控制权限,大小,拥有者,创建
	时间等信息.文件相关信息,有时被称作文件的元数据.
	被存储在一个单独的数据结构中该结构称为索引节点.它其实是index node的缩写,不过近来术语"inode"
	使用得更为普通一些.

	所有这些信息和文件系统的控制信息密切相关,文件系统的控制信息存储在超级块中,超级块是一种包含
	文件系统信息的数据结构.有时,把这些收集起来的信息称为文件系统数据元,它集单独文件信息和文件
	系统信息于一身.

	一直以来,Unix文件系统在它们物理磁盘布局中也是按照上述概念实现的.比如说在磁盘上,文件信息按照
	索引节点的形式存储在单独块中上.控制信息被集中在座在磁盘的超级块中.

	Linux的VFS设计目标就是要保证能与支持和实现了这些概念的文件系统协同工作.



13.4 VFS对象及其数据结构
	VFS其实采用面向对象的设计思路上,使用一组数据结构来代表通用文件对象.这些数据结构类似于对象.
	因为内核纯粹使用C代码实现,没有直接利用面向对象的语言,所以内核中的数据结构都使用C语言的结构
	体来实现,而这些结构体包含数据的同时也包含操作这些数据的函数指针,其中的操作函数由具体文件
	系统实现.
	VFS中有四个主要对象类型:
	*超级块对象,它代表一个具体已安装文件系统
	*索引节点对象,它代表一个具体文件.
	*目录项对象,它代表一个目录项,是路径的一个组成部分.
	*文件对象,它代表由进程打死的文件

	注意,因为VFS将目录作为一个文件来处理,所以不存在目录对象.回忆本章前面所提到的目录项代表的是
	路径中的一个组成部分,它可能包括一个普通文件.目录项不同于目录,但目录却是另一种形式的文件.

	每个主要操作对象中都包含一个操作对象,这些操作对象描述符内核针对主要对象可以使用的方法:
	super_operations对象
	inode_operations对象
	dentry_operations对象
	file_operations对象
	
	操作对象作为一个结构体指针来实现,此结构体中包含指向操作其父对象的函数指针.对于其中许多方法来
	说,可以继承使用VFS提供的通用函数,如果通用函数提供的基本功能无法满足基本需求,那么就必须使用实际
	文件系统独有方法填充这些函数指针.

    我们这里说的对象就是指结构体
	VFS使用大量结构对象,它所包括的对象远远多于上面提到的这几种.
	比如每个注册的文件系统都由file_system_type结构体来表示
	每一个安装点也都用vfsmount结构体表示,它包含的都是安装点的信息
	在本章的最后还要介绍两个与进程相关的结构体,它们描述了文件系统和进程相关的文件,分别是fs_struct
	和file


13.5 超级块对象
	各种文件系统都必须实现超级块对象,该对象用于存储特定文件系统的信息,通常对于存放在磁盘
	特定扇区中的文件系统控制块对于并非基于磁盘的文件系统,它们会在使用现场创建超级块并将其
	保存到内存中.
		超级块对象由super_block结构体表示,下面给出了它的结构各个域的描述.
		struct super_block{
			struct list_head;
		};

创建,管理和撤销超级块对象的代码位于文件fs/super.c中,超级块对象通过alloc_super()
	函数创建并初始化.在文件系统安装,文件系统会调用该函数以便从磁盘读取文件系统超级块,
	并将其信息填充到内存中的超级块对象中.

13.6 超级块操作
	超级块对象中最重要的一个域是s_op它指向超级块的操作函数表.超级块操作函数表由
	super_operations结构体表示,定义在文件中,其形式如下:
	struct super_operations{
	};

	该结构体中的每一项都是一个指向超级块操作函数的指针,超级块操作函数执行文件系统
	索引节点的低层操作.


	当文件系统需要对其超级块执行操作时,首先要在超级对象中寻找需要操作方法.比如
	如果一个文件系统要写自己的超级块,需要调用:
	sb->s_op0->write_super(sb);
	在这个调用中,sb是指向文件系统超级块的指针,沿着指针进入超级块操作函数表s_op,
	并从表中取得希望得到的write_super()函数,该函数执行写入超级块的实际操作.
	注意,尽管write_super()方法来自超级块,但是在调用时,还是要把超级块作为参数
	传递给它,这是因为C语言

	由于在C语言中无法直接得到操作函数的父对象,所以必须将父对象以参数形式传给操作函数.
	下面给出super_operation超级块操作函数的用法.

	在给定的超级夫下创建和初始化一个新的索引节点对象
	void destory_inode(struct inode *inode)

	用于释放给定的索引节点
	void dirty_inode(struct inode *inode)

	VFS在索引节点
	...

	这其中的一些函数是可选的,在操作块操作表中,文件系统可以将不需要的函数指针设置成NULL
	如果VFS发现操作函数指针是NULL,那它要么就会调用通用函数执行相应操作,要么什么也不做,
	如何选择取决于具体操作.


13.7 索引节点对象
	索引节点对象包含了内核在操作文件或目录时需要的全部信息.对于Unix风格的文件系统来说,
	这些信息可以从磁盘索引节点直接读入.如果一个文件系统没有索引节点,那么,不管这些相关
	信息在磁盘上是怎么存放的.文件系统都必须提取这些信息.
	没有索引节点的文件系统通常将文件描述信息作为文件的一部分来存放.这些文件系统与Unix
	风格的文件系统不同.

	struct inode{
	};

	一个索引点代表文件系统中的一个文件,它也可以是设备或者管道这样的特殊文件
	.因此索引节点结构体中有一些特殊文件相关的项,比如i_pipe项就指向一个代表管道的数据结构,i_bdev
	指向块设备结构体,i_cdev指向字符设备结构体,这三个指针被存放在一个公用体中,因为一个给定索引节点
	每次只能表示三者之一

	有时,某些文件系统可能并不能完成地包含索引节点结构体要求的所有信息.



13.8 索引节点操作
	

13.9 目录项对象
	VFS把目录当作文件对待,所以在路径/bin/vi中,bin和vi都属于文件--bin是特殊的目录文件而vi是一个
	普通文件,bin是特殊的目录文件而vi是一个普通文件,路径中的每个组成部分都由一个索引节点对象表示.
	虽然它们可以统一由索引点表示,但是VFS经常需要执行目录相关的操作,比如路径名查找等.
	路径名查找需要解析路径中的第一个组成部分.

	为了方便查找,VFS引入了目录项的概念.每个dentry代表路径中的一个特定部分.对前一个例子来说
	/ bin vi都属于目录项对象.前两个是目录,最后一个是普通文件.必须明确一点.
	在路径中,第一个部分都是目录项对象.解析一个路径并遍历其分量绝非简单的演练,它是常规字符串比较过程.
	目录项对象引入使得这个过程更加简单.

	目录项可包括安装点.在路径/mnt/cdrom/foo中构成元素/ 都属于目录项对象.VFS在执行目录操作时会现场
	创建目录项对象.

	目录项对象由dentry结构体表示,定义在文件linux/dcache.h 下面给出该结构体和其中各项的描述

	struct dentry{
	}
	与前面的两个对象不同,目录项对象没有对应磁盘数据结构,VFS根据字符串形式的路径名现场创建它.而且由
	于目录项对象并非保存在磁盘上,所以目录项结构体没有是否被修改的标志

	13.9.1 目录项状态
	目录项对象有三种状态:被使用,未使用,未被使用和负状态.
	一个被使用的目录项对应一个有效的索引节点(即d_inode指向相应的索引节点)并且表明该对象存在
	一个或多个使用者.一个目录项处于被使用状态,意味着它正被VFS使用并且指向有效的数据,因此不
	能被丢弃.
	
	一个未被使用的目录项对应一个有效的索引节点(d_inode指向一个索引节点),但是应指明VFS当前并
	未使用它.该目录项对象仍然指向一个有效对象,而且被保留在缓存中以便需要时再使用它.由于该
	目录项不会过早地被撤销,所以以后再需要它时,不必重新创建,与未缓存的目录项相比,这样路径查找
	更迅速.但是如果要回收内存的话,可以撤销未使用的目录项.
		一个负状态的目录项没有对应的有效索引节点,因为索引节点已被删除了,或路径不再正确了,但是
	目录项仍然保留,以便快速解析以后的路径查询.比如,一个守护进程不断地去试图打开并读取一不存在
	的配置文件.open()系统调用不断地返回ENOENT,直到内核构建了这个路径,遍历磁盘上的目录结构体并
	检查这个文件的确不存在为止.即便这个失败的查找很浪费资源,但是将负状态缓存起来还是非常
	值得的.虽然负状态的目录项有些用处,但是如果有需要,可以撤销它,因为毕竟实际上很少用到它

	目录项对象释放后也可以保存到slab对象缓存中去,这点在第12章讨论过.此时任何VFS或文件系统代
	码都没有指向该目录项对象的有效引用.

	13.9.2 目录项缓存
		如果VFS层遍历路径名中所有的元素并将它们逐个地解析成目录项对象,还要到达最深层目录,
		将是一件非常费力的工作,会浪费大量的时间,所以内核将目录项对象缓存在目录项缓存中.
		目录项缓存包括三个主要部分:
		*"被使用的"目录项链表
		*"最近被使用的"双向链表
		*散列表和相应的散列函数用来快速地将给定路径解析为相关目录项对象.
		散列表由数组dentry_hashtable表示,其中每一个元素都是一个指向具有相同键值的目录项
		对象链表的指针.数组的大小取决于系统中物理内存的大小.
		实际的散列表要通过d_lookup函数,如果该函数在dcache中发现了与其相匹配对象,则匹配
		对象被返回,否则,返回NULL指针.

		而dcache在一定意义上也提供对索引节点的缓存,也就是icache.
		和目录项对象相关的索引节点对象不会以被释放,因为目录项会让相关索引节点的使用计数
		为正,这样就可以确保索引节点留在内存中.

		因为文件访问呈现空间和时间的局部性,所以对目录项和索引点进行缓存非常有益.文件访问有
		时间上的局部性,是因为程序可能会一次又一次地访问相同的文件.因此一个文件被访问时,
		所缓存的相关目录项和索引节点不久被命中的概率较高.文件访问具有空间的局部性是因为
		程序可能在同一个目录下访问多个文件,因此一个文件对应的目录项缓存后极有可能被命中,因为
		相关的文件可能在下次又被使用.

13.10 目录项操作
	dentry_operations结构体指明了VFS操作目录项的所有方法.
	该结构定义在文件linux/dcache.h

	struct dentry_operations{
	};



13.11 文件对象
VFS的最后一个主要对象是文件对象.文件对象表示进程已打开的文件.如果我们站在用户角度来看待VFS.
文件对象会首先进入我们的视野.进程直接处理的是文件,而不是超级块.索引节点或目录项.

文件对象包含我们非常熟悉的信息(如访问模式, 当前偏移等)
同样道理,文件操作和我们非常熟悉的系统调用read() write()等也很类似

文件对象是已经打开的文件在内存中的表示.该对象由相应的open()系统调用创建.由
close()系统调用撤销,所有这些文件相关的调用实际上都是文件操作表中定义的方法,
	因为多个进程可以同时打开和操作同一个文件,所以同一个文件也可能存在多个对应
	的文件对象.文件对象仅仅在进程观点上代表已打开文件,它反过来指向目录项对象
	其实只有地目录项对象才表示已打开的实际文件,虽然一个文件对应的文件对象不是
	唯一,但对应的索引节点和目录项对象无疑是唯一的.

	文件对象由file结构体表示,定义在文件linux/fs.h中,下面给出该结构体和各项的描述.
	struct file{
		union {
			struct list_head  fu_list;
			struct rcu_head   fu_rcuhead;
		} f_u;
		struct path
			...
			...

	类似于目录对象,文件对象实际上没有对应的磁盘数据,所以在结构中没有代表其对象
	是否...,文件对象通过f_dentry指针指向相关的目录项对象.目录项会指向相关的索引
	节点,索引节点会记录文件是否脏.

13.12 文件操作
	和VFS的其它操作对象一样,文件操作表在文件对象中也非常重要.跟file结构体相关的操作
	与系统调用很类似,这些操作是标准Unix系统调用的基础.

	具体的文件系统可以为每一种操做专门的实现,或者如果存在通用操作,也可以使用通用
	操作.一般在基于Unix的文件系统上,这些通用操作效果都不错.并不要求实际文件系统
	实现文件操作函数表中的所有方法----虽然不实现最基础的那些操作显然很不明智,
	对不感兴趣的操作完全可以简单地将该函数指针置为NULL.
		下面给出操作的用法说明:
		*loff_t lleek

		*
		...

		如此之多的loctls
		不久之前,只有一个单独的ioctl方法.如今,有三个相关的方法.
		unlocked_ioctl()
		和ioctl相同,不过前者在无大内核锁(BKL)情况下被调用.因此函数的作者必须确保
		适当的同步.因为大内核锁是粗粒度,低效的锁,驱动程序应当实现unlocked_ioctl()
		而不是ioctl()

		compat_ioctl()也在无大内核锁的情况下被调用,但是它的目的是为64位的系统
		提供32位ioctl

13.13 和文件系统相关的数据结构
  除了以上几种VFS基础对象外,内核还使用另外一些标准数据结构来管理文件系统的其他相关数据
  第一个对象是file_system_type,用来描述各种文件系统类型,比如ext3 ext4 或UDF.
  第二个结构体是vfsmount,用来描述一个安装文件系统的实例.

	因为Linux支持众多不同的文件系统,所以内核必须由一个特殊结构来描述每种文件系统的功能
	和行为.file_system_type结构体被定义在linux/fs.h中具体实现如下:
	struct file_system_type{
	}

	get_sb()函数从磁盘上读取超级块
	更有趣的事情是,当文件系统被安装时,将有一个vfsmount结构体在安装点被创建.
	该结构体用来代表文件系统的实例----换句话说,代表一个安装点.
	struct vfsmount{
		...
	};

	理清文件系统和所有其他安装点之间的关系,是维护所有安装点链表中最复杂的工作
	所以vfsmount结构体中维护的各种链表不就是为了能够跟踪这些关联信息.
	vfsmount结构还保存了在安装时指定的标志信息,该信息存储在mnt_flages中列出了标准的安装标志

	                        禁止该文件系统的可执行文件设置
	MNT_NOSUID              禁止访问该文件系统上的设备文件
	MNT_MODEV               禁止访问该文件系统上的设备文件
	MNT_NOEXEC              禁止执行该文件系统上的可执行文件

    安装那些管理员不充分信任的移动设备时,这些标志很有用处.它们和其他一些很少用的标志一起定义
	在linux<linux/mount.h>中.

13.14 和进程相关的数据结构
	系统中的每一个进程都有自己的一组打死的文件,像文件系统,当前工作目录,安装点等.
	有三个数据结构将VFS层和系统的进程紧密联系在一起,它们分别是:file_struct, fs_struct和namespace
	结构体.
		
	file_struct结构休由进程描述符中的files目录项向,所有与单个进程相关信息都包含其中
	fd_array数据指针指向已打开的文件对象.

	和进程相关的第二个结构体是fs_struct.该结构由进程描述符的fs域指向.
	它包含文件系统和进程相关的信息,定义在文件<linux/fs_struct.h>中,下面是它具体结构体和各项描述:
	struct fs_struct{
	}

	该结构包含了当前进程的当前工作目录(pwd)和根目录
	第三个也是最后一个相关结构体是namespace结构体.由进程描述符中的mmt_namespac域指向.2.4版内核以后
	单进程命名空间被加入到内核中,它使得每一个进程中都看到唯一的安装文件系统,不仅是唯一的根目录,而且
	是唯一的文件系统层次结构.下面是其具体结构和描述:

	struct mmt_namespace{
		atomic_t           count;
		struct vfsmount    *root;
		struct list_head list;
		wait_queue_head_t  poll;
		int                event;
	}
	 上述这些数据结构都是通过进程描述符连接起来的.对多数据进程来说.它们的描述符都指向唯一的
	 files_struct 和fs_struct 结构体.但是,对于那些使用克隆标志CLONE_FILES或fs_struct结构体.
	 每个结构体都维护一个count域作为引用计数,它防止在进程正使用该结构时,该结构被撤销.

	 namespace结构体的使用方法却和前两种结构体完全不同,默认情况下,所有的进程共享同样的命名空间
	 (也就是,它们都从相同的挂载入表中看到同一个文件系统层次结构).只有在进行clone()操作时
	 使用CLONE_NEWS标志,才会给进程一个唯一的命令空间结构体的拷贝.因为大多数进程不提供
	 这个标志,所有进程都与其父进程命名空间国.因此在大多数系统上只有一个命名空间,不过
	 CLONE_NEWS标志可以使这一功能失效.

13.15 小结
	本章描述了VFS的目的,讨论了各种数据结构,包括重要索引节点,目录项以及超级块对象.
	第14章将讨论如何从物理上存放在文件系统中.
	


	




	













