第17章  设备与模块


在本章节中,关于设备驱动和设备管理,我们讨论四种内核成分.

*设备类型:在所有Unix系统中为了统一普通设备的操作所采用的分类.
*模块:Linux内核中用于按需加载和xie载目标码的机制.
*内核对象: 内核数据结构中支持面象对象的简单操作,还支持维护对象之间的父子关系.
*sysfs:表示系统中设备树的一个文件系统.


17.1 设备类型
在Linux以及所有Unix系统中,设备被分为以下三种类型:
*块设备
*字符设备
*网络设备

	块设备通常缩写为blkdev,它是可寻址的,寻址以块为单位,块大小随设备不同而不同;
	块设备通常支持重定位操作,也就是对数据的随机访问.块设备的例子有硬盘,蓝光光碟,
	还有如Flash这样的存储设备.块设备是通过称为"块设备节点"的特殊文件来访问的,
	并且通常被挂载为文件系统.

	字符设备通常缩写为cdev,它是不可寻址的,仅仅提供数据的流式访问,就是一个个字符,
	或者一个个字节.字符设备的例子有键盘,鼠标,打印机,还有大部分伪设备.
	字符设备是通过称为"字符设备节点"的特殊文件来访问的,与块设备不同,应用程序通过
	直接访问设备节点与字符设备交互.

	网络设备最常见的类型有时也用以太网设备来称呼.它提供了对网络的访问.
	这是一个物理适配器和一种特定的协议(如IP协议)进行的.网络设备打破了Unix的"所有东西
	都是文件"的设计原则,它不是通过设备节点来访问,而是通过API这样特殊接口来访问.
	
	Linux还提供了不少其他设备类型,但都是针对单个任务,而非通用的.一个特例是杂项设备
	miscellaneous device通常简写为miscdev,它实际上是个简化的字符设备,杂项设备使用驱动
	程序开发者能够很容易表示一个简单设备--实际上是对通用基本架构的一种折中.

	并不所有设备驱动都是表示物理设备.有些设备驱动是虚拟的,仅提供访问内核功能而已.
	我们称为"伪设备",最常见的如内核随机数发生器,空设备,零设备,满设备,还有内存设备
	,然而,大部分设备驱动是表示物理设备的.

17.2 模块
	尽管Linux是"单块内核"的操作系统--这是说整个系统内核都运行于一个单独的保护域中,但是
	Linux内核是模块化组成的.它允许内核在运行时动态地向其中插入或从中删除代码.这些代码
	被一并组合在一个单独的二进制镜像中,即所谓的可装载内核模块中,或简称为模块.支持模块的
	好处是基本内核镜像可以尽可能地小,因为可选的功能和驱动程序可以利用模块的形式再提供.
	模块允许我们方便地删除和重新载入内核代码.而且当热插拨新设备时,可通过命令载入新的驱动
	程序.
	本章我们将探寻内核模块的奥秘,同时也学习如何编写自己的内核模块

17.2.1 Hello, world
	与开发我们已经讨论过的大多数内核核心子系统不同,模块开发更接近编写新的应用系统,因为
	至少在模块文件中具有入口和出口点.
	....
	....
	....
	....
	....
这大概是我们所能见到的最简单的内核模块了,hello_init()函数是模块的入口点,它通过module_init()
	例程注册到系统中,在内核装载时被调用.调用module_init()实际上不是真正的函数调用,而是一个
	宏调用,它唯一的参数便是初始化函数.模块的所有初始化函数必须符全以下形式

	int my_init(void); 
	因为init函数通常不会被外部函数直接调用,所以你不必导出该函数,故它可标记为static类型

	init函数会返回一个int型数值,如果初始化(或你的init函数想做的事情)顺利完成,那么它的返回值
	为零;否则返回一个非零值.

	这个init函数仅仅打印了一条简单的消息,然后返回零.在实际的模块中,init函数还会注册资源,
	初始化硬件,分配数据结构等.如果这个文件被静态编译进内核映像中,其中init函数将存放在内核
	映像中,并在内核启动时运行.
	
	hello_exit()函数是模块的出品函数,它由module_exit()例程注册到系统.在模块从内存,内核便会
	调用hello_exit(),(ve)退出函数可能会在返回前负责对init函数以及在模块生命周期过程中所做的
	一切事情进行撤销工作,基本上就是清理工作,退出函数必须符以下形式:
	void my_exit(void);
	与init函数一样,你也可以标记其为static.
	如果上述文件被静态编译到内核映像中,那么退出函数将不被包含,而且不会被调用(因为如果不是
	编译成模块的话,那么代码就不需要从内核)

	MODULE_LICENSE()宏用于指定模块的版权.如果载入非GPL模块到系统内存,则会在内核中设置被
	污染标识----这个标识只起到记录信息的作用.
	版权许可证明具有两大目的.首先,它具有通告的目的.当OOPS中设置了被污染的标识时,很多内核
	开发者对bug的报告
	因为他们认为二进制模块(也就是开发者不能调试它)被装载到了内核.其次,非GPL模块不能调用
	GPL_only符号,本章后续"导出符号表"一节将对其加以描述.

	最后还要说明.MODULE_AUTHOR()宏和MODULE_DESCRIPTION()宏指定了代码作者和模块的简要描述,
	它们完全是作信息记录目的.

17.2.2 构建模块
		
	在2.6内核中,由于彩了新的"kbuild"构建系统,现在构建模块相比从前更加容易.构建过程的第一步
	是决定在哪里管理模块源码.你可以把模块源码加入到内核源代码树中,或者是作为一个补丁或者是最
	终把你的代码合并到正式的内核代码树中;另一种可行的方式是在内核源码树之外维护和构建你的
	模块源码.

	1.放在内核源代码树中




	最理想的情况是莫过于你的模块正式成为Linux内核的一部分,这样就会被存放入内核源代码树中.把
	你的模块代码正确地置于内核中,开始的时候难免需要更多的维护,但这样通常是一劳的解决之道.
	
	当你决定了把的模块放入内核源代码树中,下一步清楚你的模块应在内核源代码树中处于什么位置,
	设备驱动程序放在内核源码树根目录下/drviers的子目录下,在其内部,设备驱动文件被进一步按
	类别,类型或者特殊驱动程序等更有序地组织起来.如字符设备存在于drvier/char/目录下,而块设备
	存放在drivers/block/目录下,USb设备则存放在drivers/usb/目录下.文件的具体组织规则并不须
	绝对墨守成规,不容打破,你可看到许多的USB设备也属于字符设备,但是不管怎么样,这些组织关系对
	我们来说相当容易理解,而且很准确.

	假定你有一个字符设备,如果只有地一个在drivers/char/目录下建立一个名为fishing的子目录.
	接下来需要向drvier/char/下的Makefile文件添加一行.编辑drivers/char/Makefile/并下加入
	obj-m += fishing/
	这行指令是告诉模块构建系统,在编译模块时需要进入fishing/了目录中,更有可能发生的情况是,你
	的驱动程序的编译取决于一个特殊配置选项.如果,可能CONFIG_FISHING_POLE.如果这样,你需要用
	下面的指令代替刚才那条指令

	obj-$(CONFIG_FISHING_POLE) += fishing/
	最后,在drivers/char/fishing/下,需要添加一个新的Makefile文件,其中需要有下面这行指令
	obj -m += fishing.o
	一切就绪了,此刻构建系统运行将会进入fishing/目录下,并且将fishing.c编译为fishing.ko
	模块.虽然你写的扩展名是.o,但是模块被编译后的扩展名却是.ko
	再一个可能,要是你的钓鱼驱动程序有编辑选项,那么你可能需要这么来做:

	obj-$(CONFIG_FISHING_POLE) += fishing.o
	以后,假如你的钓鱼驱动程序需要更加智能化----它可以自动检测钓鱼线,这可是最新鱼的必备要求
	这时驱动程序源文件就可能不再只有一个了,你要把makefile做如下修改就可以搞定:
	obj -$(CONFIG_FISHING_POLE) += fishing.o
	fishing-objs := fishing-main.o fishing-line.o
	每当设置了CONFIG_FISHING_POLE,fishing-main.c和fishing-line.c就一起编译和连接到fishing.ko
	模块内.

	最后一个注意事项是,在构建文件时你可能需要额外的编译标记,如果这样,你只要需在Makefile中添加
	如下指令:
	EXTR_CFLAGS += -DTITANTUM_POLE
	

	如果喜欢把你的源文件置于drivers/char/目录下,并且不建立新目录的话,那么你要做便是将前面
	提到的行(也就是原来处于drivers/char/fishing/下你自己的Makefile中的)都加入到
	drivers/char/Makefile中

	开始编译吧,运行内核构建过程和原来一样,如果你的模块编译取决于配置选项,比如有CONFIG_FISHING_POLE
	约束,那么在编译前首先要确保选项被允许.


	2.放在内核代码外
	如果你喜欢脱离内核源代码树来维护和构建你的模块,把自己作为一个圈外人,那么你要做的就是在你
	自己的源代码树目录建立一个makefile文件,它只需要一行指令:
	obj-m := fishing.o
	这条指令就可把fishing.c编译成fishing.ko.如果你有源文件,那么用两行就足够
	obj-m := fishing.o
	fishing-objs := fishing-main.o fishing-line.o	
	这样一来fishing-main.c和fishing-line.c就一起被编译和连接到fishing.ko模块内了.
	模块在内核和内核外构建最大的区别在于构建过程.当模块在内核源.你必须要告诉make如何
	找到内核源代码文件和基础Makefile文件.不过要完成这个工作同样不难
	make -c /kernel/source/location SUBDIRS =$ PWD modules
	在这个例子中/kernel/source/location是你配置的内核源代码树.回想一个
	不要把处理的内核源代码放在/usr/src/linux下,而是要移动你home目录下某个方便访问的地方.

17.2.3 安装模块
	编译后的模块将被装入到目录/lib/modules/version/kernel/下,在kernel目录下的每一个目录
	都对应着内核源码中的模块位置.如果使用的是.2.6.34内核,而且你的模块源代码直接放在
	drivers/char下.那么编译后的钓鱼驱动程序存放路径将是:/lib/modules/2.6.34/kernel/drivers/
	char/fishing.ko
	下面的构建命令用来安装编译的模块到合适的目录下:
	make modules_install

17.2.4 产生模块信赖性,也就是说钓鱼模块信赖于鱼饵模块,那么当你载入钓鱼模块时,鱼饵模块会被自动载入
	这里需要的依赖信息必须事先生成.多数Linux发布版都能自动产生这些信赖关系信息.并且在每次
	启动更新时,若想产生内核信赖关系的信息,root用户运行命令
	depmod
	depmod -A
	模块信赖关系信息存放在/lib/moduleles/version/moduleles.dep文件中

17.2.5 载入模块
	载入模块最简单的方法是通过insmod命令,这是个功能很有限的命令,它能做的就是
	请求内核载入指定的模块.insmod程序不执行任何依赖性分析或进一步错误检查.它用法简单,
	以root
	insmod module.ko
        	
	rmmod module
	这两个命令很简单,但是它们一点也不智能.先进工具modprobe提供了模块信赖性分析
	错误智能检查,错误报告以及许多其他功能和选项.我强烈建议大家用这个命令.
	为了在内核via modprobe中插入模块
	其中参数module指定了需要载入的模块名称,后面的参数将在模块加载时传入内核.
	modprobe命令不但会加载指定的模块,而且会自动加载任何它所依赖的有关模块.
	所以它是加载模块的最佳机制.

	modprobe -r modules
	参数modules指定一个或多个.与rmmod命令不同,modprobe也会给定模块所信赖的相关模块
	但其前提是这些模块没有被使用.Linux用户手册第8部分提供了上述命令的使用参考,里面包括
	了选项和用法.

17.2.6 管理配置选项
	在前面的内容中我们看到,只要设置了CONFIG_FISHING_POLE配置选项,钓鱼模块就会自动被编译
	虽然配置选项在前面已经讨论过了,但这里我们将继续以钓鱼驱动为例,再看看一个新的配置选项
	如何加入.

	由于2.6内核新引入了"Kbuild"系统,因此,加入一个新配置选项现在可以说是易如反掌.你所需
	做的全部就是向Kconfig文件中添加一项,用以对就内核源码树,对驱动而言,kconfig通常和源
	代码处于同一目录.如果钓鱼驱动在driver/char/下,那么你便会发现
	driver/char/kconfig也同时存在.

	如果你建立了一个新子目录,而且也希望kconfig文件存在于该目录中的话,那么你必须在一个
	已存在的Kconfig文件将它引入.你需要加入下面一行指令:
	source "drivers/char/fishing/Kconfig"

	这里所谓存在的Kconfig文件可能是drivers/char/Kconfig
	Kconfig文件很方便加入一个配置造型,请看钓鱼模块的选项,如下所示:
	config FISHING_POLE
		tristate "Fish Master 3000 support"
		default n
		help 
		 If you say ....
		  ....
		 If unsure, say N.

	配置选项第一行定义了该选项代表的配置目标.注意CONFIG_前缀并不需要写上.
	第二行声明选项类型为tristate,也就是说可以编译进内核(Y),也可以作为模块
	模块(M),或者不编译它(N).如果编译选项代表的是一个系统功能,而不是一个
	模块,那么编译选项将用bool指令代替tristate,这说明它不允许被编译成模块.处于指令之后的引号
	内文字为该选项指定了名称.

	第三行指定了该选项的默认选择,这里默认操作是不编译它(N).也可以把默认选择指定为编译进内核
	Y,或者编译一个模块.对驱动程序而言,默认选择通常为不编译进内核(N)
	Help指令的目的是为该选项提供帮助文档.各种配置工具都可以按要求显示这些帮助.
	因为这些帮助是面向编译内核的用户和开发者的,所以帮助内容简洁扼要.一般的用户通常不会
	编译内核.

	除了选项以外,还存在其他选项.比如depends指令规定了在该选项被设置前,首先要
	设置的选项.假如信赖性不满足,那么该选项就被禁止,比如,如果加入指令:
	depends on FISH_TANK
	到配置选项中,那么就意味着在CONFIG_FISH_TANK被选择前,我们的钓鱼模块是不能使用的(Y或者M)
	Select指令和depends类似,它们只有一点不同之处----只要是select指定了谁,它就会强行被指定的
	选项打开.所以这个指令可不能向depends那样滥用一通,因为它会自动的激活其他配置选项,它的
	用法和depends一样.比如:
		select BAIT
		意味着当CONFIG_FISHING_POLE被激活时,配置选项CONFIG_BAIT必然一起被激活.
		如果select和depends同时指定多个选项,那就需要通过&&指令来进行多选.使用depends时,你还
		可以利用叹号前缀来指明禁止某个选择.比如:
		depends on EXAMPLE_DRIVERS && !NO_FISHING_ALLOWED
		这个指令就指定驱动程序安装要求打开CONFIG_EXAMPLE_DRIVERS选项,同时
		要禁止CONIFG_NO_FISHING_ALLOWED

		tristate和bool选项往往会结合if指令一起使用,这表示某个选项取决于另一个配置选项.
		如果条件不满足,配置选项不但会被禁止,甚至不会显示在配置工具中,比如,要求配置系统
		只有在CONFIG_x86配置选项设置时才显示某选项.请看下面指令:
		bool "deep Sea Mode"if OCEAN
		If指令也可以与default指令结合使用,强制只有在条件满足时default选项才有效.
		配置系统导出一些元素选项以简化生成配置文件,比如选项(CONFIG_EMBEDDED)是
		用于关闭那些用户想要禁止的关键功能(比如要在嵌入式)
		选项CONFIG_BROKEN_ON_SMP用来表示驱动程序并非多处理器安全的.通常该项不



17.2.7 模块参数
	Linux提供了这样一个简单框架----它允许驱动程序声明函数,从而用户可以在系统启动或者模块装载
	时再指定参数值,这些参数对于驱动程序属于全局变量.值得一提的是模块参数同时也将出现在sysfs
	文件系统中,这样一来,无论是生成模块参数,还是管理模块参数的方式都变得灵活多样了.
	定义一个桃花运灰鼠可通过宏module_param()完成:
	module_param(name, type, perm);
	参数name既是用户可见的参数名,也是你模块中存放模块参数的变量名.参数type则存放
	了参数的类型,它可以是byte,short,ushort,int uint,long,ulong,charp,bool或invbool
	
	其中byte类型存放在char类型变量中,boolean类型存放在int变量中,最后一个参数perm指定
	了模块在sysfs文件系统下对应文件的权限,该值可以是八进制的格,如果值是零,则表示禁止
	所有的sysfs项.

	上面的宏其实并没有定义变量,你必须在使用该宏前进行变量定义.通常使用类似下面的
	语句完成定义:
	/* 在模块参数控制下,我们允许在钓鱼*/

	这个值处于模块代码文件外部,换句话说,allow_live_bait是个全局变量.
	有可能模块的外部参数名称不同于它对应的内部变量名称,这时就该使用宏module_param_named()
	定义了:
	参数name是外部可见的参数名称,参数variable是参数对应的内部全局变量名称.

	通常需要用一个charp类型来定义模块参数,内核将用户提供的这个字符拷贝到内存,而且将变量
	指向该字符串.比如:
	如果需要,也可使内核直接拷贝字符串到指定的字符数组.宏

17.2.8 导出符号表
	模块被载入后,就会被动态地连接到内核.注意,它与用户空间中的动态链接库类似,只有当被显式导
	出后的外部函数,才可以被动态库调用.在内核中,导出内核函数需要使用特殊指令:
	EXPORT_SYMBOL()和EXPORT_SYMBOL_GPL()

	导出的内核函数可以被模块调用,而未导出的函数模块则无法被调用.模块代码的链接和调用规则
	相比核心内核镜像中代码而言,要更加严格.
	核心代码在内核中可以调用任意非静态接口.因为所有核心源代码文件被链接成了同一个镜像.当然,
	被导出的符号表所含的函数必然也要是非静态的.
	导出的内核符号表被看作导出的内核接口,甚至称为内核API.导出符号相当简单,在声明函数后,
	紧跟上EXPORT_SYMBOL()指令就搞写了,比如:

	假定get_pirate_beard_color()同时也定义在一个可访问的头文件中,那么现在任何模块都可以访问
	它,有一些开发者希望自己的接口仅仅对GPL兼容的模块可见,内核连接器使用
	MODULE_LICENSE()
	可满足这个要求.如果你希望先前的函数仅仅对标记为GPL的模块可见,那么你就需要用:
	EXPORT_SYMBOL_GPL(get_pirate_beard_color);
	如果你的代码被配置为模块,那么你必须确保当它被编译为模块时,它所用的全部接口都已被导出,否则
	就会产生连接错误(而且模块不能成功编译)


17,3 设备模型
	2.6内核增加了一个引人注目的新特性----统一设备模型.设备模型提供了一个独立的机制专门来表示
	设备,并描述其在系统中拓扑结构,从而使得系统具有以下优点:
	*代码重复最小化.
	*提供诸如引用计数这样的统一机制.
	*可以列举系统中所有的设备,观察它们的状态,并且查看它们的连接的总线.
	*可以将系统中的全部设备结构以树的形式完整,有效地展示出来----包括总线和内部连接

	*可以将设备和其对应驱动联系起来,反之
	*可以将设备按照类型加以归类,比如分类为输入设备,而无需理解物理设备的拓扑结构.
	*可以沿设备树的叶子向其根的方向依次遍历,以保证能以正确顺序关闭各设备电源.

	最后一点是实现设备模型的最初的最初动机
	若想在内核中实现智能电源管理,就需要建立表示系统中设备拓扑关系的树结构.
	当在树上端设备关闭电源时,内核必须首先关闭该设备节点以下设备电源.如果内核需要先关闭
	一个USb mouse然后才可关闭USB控制器,同样内核也必须在关闭PCI总线前先关闭USB控制器.简
	而言之,若要准确而又高效地完成上述电源管理目标,内核无疑需要一棵设备树.

	17.3.1 kobject
	设备模型的核心部分就kobject(kernel object),它由struct kobject结构体表示,定义于头文件
	<linux/kobject.h>
	看下面的具体结构:
	struct kobject {
		const char          *name;
		struct list_head    entry;
		struct kobject      *parent;
		...
		...
		...
		...
	}
	name指针指向此kobject的名称.

	parent指针指向kobject的父对象.这样一来,kobject就会在内核中构造一个对象层次结构,
	并且可以将多个对象间的关系表现出来.就如你所看到,这便是sysfs的真正面目:一个用户
	空间的文件系统,用来表示内核中kobject对象的层次结构.

	sd指针指向sysfs_dirent结构体,该结构体在sysfs中表示的就是这个kobject.从sysfs文件
	详细系统内部看,这个结构是表示koject的一个inode结构体.

	kref提供引用计数.ktype和kset结构体对kobject对象进行描述和分类.在下面的内容中
	将详细介绍它们.
	kobject通常嵌入其他结构中的,其单独意义并不大.相反,那些更为重要的结构体,
	比如定义于cdev.h中的struct cdev中才真正需要用到kobj结构.

	当kobjectP被嵌入到其他结构中时,该结构便拥有了kobject提供的标准功能.更重要的一点为是
	嵌入koject的结构体可以成为对象层次架构中的一部分.比如cdev结构体就可通过其父指针
	cdev->kobj.parent和链表cdev->kobj.entry插入到对象层次结构中.

17.3.2 ktype
	kobject对象被关联到一种特殊的类型,即ktype(kernel object type的缩写).
	ktype由kobj_type结构体表示,定义于头文件<linux/kobject.h>中:
	struct kobj_type{
		void
		...
	}

ktype的存在是为了描述一族kobject所具有的普遍特性.
如此一来,不再需要每个kobject都分别定义自己的特性,而是将这些普遍的特性在ktype结构中
一次定义,然后所有"同类"的kobject都能共享一样的特性.
release析构函数
最后,default_attrs指向一个attribute结构体数组.这些结构体定义了该kobject的默认属性.
属性描述了给定对象的特征,如果该kobject导出到sysfs中,那么这些属性都将相应地作为文件
导出,数组中最后一项必须为NULL
	
17.3.3 kset
	kset是kobject对象的集合体.把它看成是一个容器,可将所有相关的kobject对象.
	比如"全部的块设备"置于同一位置,听起来kset和ktype非常类似.好像没有多少实质内容

	kset把kobject集中到一个集合中,而ktype描述相关类型kobject所共有的特性,它们之间
	的重要区别在于:具有相同ktype的kobject可以被分组到不同的kset.就是说,在Linux内核中,
	只有少数一些ktype,却有多个kest.

	kobject的kest指针指向相应的kset集合,kset集合由Kset结构体表示,定义于头文件中
	struct kset{
		struct list_head list;
	}
在这个结构中,其中list连接该集合中所有的kobject对象,list_lock是保护这个链表中元素
的自旋锁,kobj指向的kobject对象代表了该集合的基类.
uevent_ops指向一个结构体--用于处理集合中Kobject对象的
uevent就是用户事件,提供了与用户空间信息进行通信的机制.


17.3.4 kobject ktype kset相互关系
	上文反复讨论的这一级结构体很容易令人混淆,这可还是因为它们数量繁多,也不是它们太复杂,而
	是由于它们内核相互交织.要了解kobject,很难只讨论其中的一个结构.
	这时最重要的家伙是kobject  (struct kobject)

	kobject与一个特别的ktype对象关联              ktype(struct kobj_type)
	在ktype中ktype字段指向该元旦.ktype定义了一些kobject相关的默认特性:析构...
	
	kobject又归入了称作kset的集合   (kset struct kset结构体表示)
	kset提供了两个功能
	第一:其中嵌入的kobject作为Kobject组成基类.第二,kset将相关的kobject集合在一起.
	在sysfs中,这些相关的Kobject将以独立的目录出现在文件系统中

17.3.5 管理和操作kobject
	当了解了kobject的内部基本细节后,我们来看管理和操作它的外部接口了,多数时候,
	驱动程序开发者并不必直接处理kobject.因为kobject是被嵌入到一些特殊类型结构体中的
	,而且会由相关的设备驱动程序在"幕后"管理.即使如此.
	kobject并不是有意在隐藏自己,它可以出现设备驱动代码子系统本身中使用它.
		使用kobject的第一步需要先来声明和初始化.kobject通过kobject_init进行初始化,
		该函数定义在文件
		void object_init(struct kobject *kobj, struct kobj_type *ktype);
		该函数的第一个参数就是需要初始化的kobject所在的上层结构体初始化时完成.
		如果kobject未被清空,那么只需要调用memset()即可:

		大多数情况下,该调用Kobject_create()创建kobject,或者是调用相关的辅助函数,而
		不是直接操作这个结构体

17.3.6 引用计数
	kobject的主要功能之一就是为我们提供了一个统一的引用计数系统.
	1.递增和递减引用计数
	2.kref

17.4 sysfs
	sysfs文件系统是一个处于内存中的虚拟文件系统,它为我们提供了kobject对象层次结构的视图.
	帮助用户能以一个简单文件系统的方式来观察系统中各种设备的拓扑结构.借助属性对象,kobject
	可以用导出文件折方式,将内核变量提供给用户读取与写入.

虽然设备模型的初衷是为了方便电源管理而提出的一种设备拓扑结构.但是sysfs是颇为意外的收获.为了方便
调试,设备模型的开发者决定将设备结构树导出为一个文件系统.首先sysfs代替了先前处于/proc下设备相关
文件;另外它为系统对象提供一个有效的视图.实际上,sysfs起初被称为drvierfs,它早于kobject出现.最终
sysfs使得我们认识到一个全新的对象模型非常有利于系统.
今天所有2.6内核的系统都拥有sysfs文件系统,而且几乎都都将其挂载在sys目录下.

	sysfs的诀窍是把kobject对象与目录项紧密联系起来,这点是通过kobject对象中的dentry字段实现的.
回忆12章.dentry结构体表示目录项,通过连接kobject到指定的目录项上,无疑方便地将kobject映射到目录上.
从此把kobject导出形成文件系统变得如同在内存中构建目录项一样简单.好了,kobject其实已经形成了一
棵树----就是我们心爱的对象模型体系.由于kobject被映射到目录项,同时对象层次结构也已经在内存中形成
了一棵树,因此sysfs的生成便水到渠成般简单了

	sysfs的根目录下包含了至少十个目录
	block bus class dev devices firmware fs kernel module power
	block目录下的每个子目录都对应着系统中的一个已注册的块设备.反过来,每个目录又都包含了该块设备的
	所有分区.

	bus目录提供了一个系统总线视图

	class目录包含了以高层功能逻辑组织起来的系统设备视图.

	dev目录是已注册设备节点的视图.

	devices目录是系统中设备拓扑结构视图,它直接映射出了内核中设备结构体组织层次.

	firmware目录包含了一些诸如ACPI,EDD,EFI等低层子系统的特殊树

	fs 目录是已注册文件系统视图.

	kernel目录包含内核配置项和状态信息,

	module目录则包含系统已加载模块的信息

	Power目录包含系统范围的电源管理数据.并不是所有的系统都包含这些目录,还有些系统含有其他目录

	其中最重要的目录是devices.该目录将设备模型导出到用户空间.目录结构就是系统中实际的设备拓扑.
	其他目录中的很多数据都是将devices目录下的数据加以转换加工而得.
	比如,/sys/class/net/目录是以注册网络接口这一高层概念来组织设备关系的.在这个目录中可能会
	有目录eth0,它里面包含的devices文件其实就是一个指回到devices下实际设备目录的符号连接.

	随便看看你可访问到的任何linux系统sys目录,这种系统设备视图相当准确和漂亮,而且可以看到class中高
	层概念与devices中的低层物理设备,以及bus中实际驱动程序之间互相联络是非常广泛的,当你认识到这种
	数据是开放的.换句话说,这是内核中维持系统的很好表示方式,整个经历都弥足珍贵.
	

17.4.1 sysfs中添加和删除kobject
	仅仅初始化kobject是不能自动将其导出到sysfs中的,想要把kobject导入sysfs你需要用到函数kobject_add()
	int kobject_add(struct kobject *kobj,struct kobject *parent, const char *fmt, ...)

	kobject在sysfs中的位置取决于kobject在对象层次结构中的位置.如果kobject的父指针被设置,那么
	在sysfs中kobject将被映射为其父目录下的子目录;如果给定的kobject中parent或kset字段都没有
	被设置,那么就认为kobject_add()前parent或kset字段应该进行适当的设置.不管怎么样,sysfs中代表
	kobject的目录名字是由fmt指定的,它也接受printf()样式的格式化字符串.
	辅助函数Kobject_create_and_add()把kobject_create()和kobject_add()所做的工作放在一个函数中
	众sysfs中删除一个kobject对应文件目录,需使用函数kobject_del()

	





