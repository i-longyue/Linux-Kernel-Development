第18章 调度
	从调试内核的一种可能步骤开始

18.1 准备开始
	如果能重现一个bug,就基本成功一半了.

18.2 内核中的bug
	1.明白无误的代码
	2.同步时发现的错误
	3.错误的控制硬件
	4.从降低所有程序运行性能到毁坏数据到死锁状态

	例子:一个被共享的结构,如果没有引用计数.可能在一个进程是使用后释放后,然后
	第二个进程使用,就引用了空指针.引用空指针会导致产生一个OOPS,而垃圾数据可能
	会导致系统GG.

	内核确实有一些独特的问题需要考虑,像定时器限制和竞争条件等,它们都是允许多个
	线程在内核同时运行产生的结果.

18.3 通过打印来调试
	内核提供的打印函数是printk()和C库提供printf()函数功能几乎相同.

18.3.1 健壮性
	健壮性是printk()函数最容易让人们接受的一个特质.任何时候,任何地方都能调用它.

	在系统启动过程中,终端还没有初始化之前,在某些地方不能使用它.
	除非你要调度的是启动过程最开始的那些步骤,着手进行这样的调试挑战性很强.不过
	还是有一些可以指望的.核心硬件部分的依靠此时能够工作的硬件设备与外界通信.

	解决的方法是提供一个print()变体函数----early_printk(),这个函数在在一些内核
	支持的硬件体系结构上无法实现.

18.3.2 日志等级
    printk和printf()在使用上最主要的区别就是前者可以指定一个日志级别,内核根据这个
	级别来判断是否在终端上打印信息.内核把级别比某个特定值低的所有消息显示在终端上.

	KERN_EMERG
	KERN_ALERT
	KERN_CRIT
	KERN_ERR
	KERN_WARNING
	KERN_NOTICE
	KERN_INFO

	KERN_DEBUG

	如果没有指定一个记录等级,函数会选用默认的DEFAULT_MESSAGE_LOGLEVEL,现在默认等级
	是KERN_WARNING.由于这个默认值将业存在变化的可能性,所以指定一个等级.

	内核将最重要的记录等级KERN_EMERG定为<0>
	将无关紧要的记录等级  KERN_DEBUG定为<7>

	怎样调用的printk()等级完全取于自己.

18.3.3 记录缓冲区
	内核消息都被保存在一个LOG_BUF_LEN大小的环形队列中.该缓冲区大小可以在编译时通过
	设置CONFIG_LOG_BUF_SHIFT进行调整.在处理器系统上默认值是16KB.
	环形缓冲区的唯一缺点----可能会丢失浙消息,但是与简单性和健壮性的好处相比,这点
	代价是值得的.

18.3.4 syslogd和klogd
	标准的Linux系统上,用户空间的守护进程klogd从记录缓冲区中获取内核消息,再通过syslogd
	守护进程将它们保存在系统日志文件中.klogd程序既可以从/proc/kmsg文件中,也可以通过
	syslog()系统调用读取这些消息.
	默认情况下,它选择读取/proc方式实现.不管是哪种方法,klogd都会阻塞,直到有新的内核消息
	可供读出.在被唤醒之后,它会读取出新的内核消息并进行处理.默认情况下,它就是把消息传给
	syslogd守护进程.
	syslogd守护进程把它接收到的所有消息添加进一个文件中,该文件默认是/var/log/messages.
	也可以通过/etc/syslog.conf配置文件重新指定.
	在启动klogd的时候,可以通过指定-c标志来改变终端的记录等级.

18.3.5 从printf()到printk的转换
	




