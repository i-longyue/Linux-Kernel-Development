1.Linux内核简介
2.linux内核出发
3.进程管理
4.进程调度
5.系统调用
6.内核数据结构
7.中断和中断处理
8.中断的后半部分推进
9.同步概念
10.同步方法
11.定时器和时间管理
12.内存管理
13.VFS
14.块I/O
15.进程地址空间
16.页高速缓存
17.设备模型
18.调度


第19章  可移植性
Linux是一个可移植性非常好的操作系统,它广泛支持许多不同体系结构的计算机.
可移植性是指代码从一种体系结构移植到另外一种不同的体系结构上的方便程序.
我们都知道Linux是可以移植的,因为它已经能够在各种不同的体系结构上运行了
本章节我们将讨论如何编写可移植的代码--编写内核代码和驱动时必须时刻牢记
这个问题.

19.1 可移植操作系统
	有些操作系统在设计时把可移植性作为头等大事之一,尽可能少地涉及与机器
	相关的代码.汇编代码用得少之又少,为了支持不同类型的体系结构,界面和功
	能在定义时都尽最大可能地具有普适性和抽象性.

	与之相反,还有一种操作系统完全不考虑可移植性,它们尽最大的可能追求代码
	的性能表现.尽可能多地使用汇编代码.压根就只为在一种硬件体系结构使用.
	内核的特性都是围绕硬件提供的特性设计.因此,将其移植到其他体系结构上也
	会不适用. DOS和WIndows95.

	Linux在可移植性这个方面走的是中间路线.差不多所有的接口和核心代码都是
	独立于硬件体系结构的C语言代码.需要快速执行和底层的代码都与硬件相关并
	且是用汇编语言写成的.这种实现方式使用Linux在保持可移植性的同时兼顾对
	性能的优化.当可移植妨碍性能发挥的时候,往往性能会被优先考虑.险些之外,
	代码就一定要保证可移植性.

	一般来说,暴露在外的内核接口往往是与硬件体系结构无关的.如果函数的任何
	部分需要针对特殊的体系结构(无论是出于优化的目的还是作为一种必需的选择)
	提供支持的时候,这些部分被安置在独立的函数中,等待调用,每种被支持的体系
	结构都实现了一个与体系结构相关的函数,而且会链接到内核映像之中.

	调度程序就是就是一个好例子.调度程序的主体程序是存放在kernel/sched.c
	文件中,用C编写,与体系结构无关.可是,调度程序需要进行的一些工作,比如说
	切换处理器上下文和切换地址空间等,却不得不依靠相应的体系结构完成于是
	用C语言编译写了context_switch()用于实现进程切换,而在它的内部,则会
	调用switch_to()和switch_mm()分别完成处理器上下文和地址切换.
		而对于Linux支持的每种体系结构,它们的switch_to()和switch_mm()
	实现都各不相同.所以,当Linux需要移植到新的体系结构上的的时候,只需要
	重新编写和提供这样的函数就可以了.
		与体系结构相关的代码都存放在arch/architecture/目录中,architecture
	是Linux支持的体系结构的简称.体系结构相关的代码都存放在arch/下


#19.2 Linux移植史
	当Linuxs最初把Linux带入这个世界的时候,它只能在i386上运行.在1993年开始把
	Linux向Digital Alpha体系结构上移植了.

	当前的2.6内核把体系结构的数据进一步提高到21个
	每一种体系结构本息就可以支持不同的芯片和机型,被像支持的ARM和PowerPC等体系
	结构,它们就可以支持不同的芯片和机型.


#19.3 字长和数据类型
	能够由机器一次完成处理的数据称为字.这种我们在文档中用字符(8位)和页(许多字
	通常是4KB或8KB)来计量数据是相信的.字指位置的整数数目--

	人们通常说的某个机器多少"位"他们其实说的就是该机器的字长.
	处理器通用寄存器(general-pupose registers,GPR)的大小和它的字长一样大.
	虽然物理地址空间有时个会比字长小,但是虚拟地址空间的大小也等于字长,至少
	Linux支持的体系结构中都是这样的.此外,C语言定义的long类型总是等于机器字长
	而int类型有时会比字长小.

	字,双字以及混合
		有些操作系统和处理器不把它们的标准字长称作字,相反,出于历史原因和某种
		主观的命名习惯,它们用字来代表一些固定长度的数据类型.比如说,一些系统
		根据长度把数据划分为字节(byte,8位)字(work16),双字32和四字64.
	而实际上该机是32位的.在本书中(在Linux中一般也是这样),像我们前面所讨论的那样
	一个字就代表处理器的字长.

	对于支持的每一种体系结构,linux都要将asm/types.h中的BITS_PER_LONG定义为C类型
	的长度,也就是系统的长度.
	c语言虽然规定了变量的最小长度,但是没有规定变量具体的标准长度,它们可以根据实
	现变化国.
	牢记下述准则:
	*ANSI C标准规定,一个char长度一定是1字节.
	*尽管没有规定int类型长度是32,但是在Linux当前所支持的体系结构中,它都是32位的
	*short类型也类似,在当前所有支持的体系结构中,虽然没有明文规定,但是它都是16位
	的.
	*绝不应该假定指针和long的长度,在Linux当前支持的体系结构中,它们可以在64位和
	32位中变化.
	*由于不同体系结构的long的长度不同,决不应该假设sizeof(int) = sizeof(long)
	*类似地,也不要假设指针和int长度相等.

##19.3.1 不透明类型
	不透明数据类型隐藏了它们内部格式或结构.在C语言中,开发者们利用typedef声明一
	个类型.把它叫做不透明类型.希望其他人别去把它转化为对应的那个标准C类型.
	pid_t类型.
	另一个不透明类型的例子是atomic_t.在第10章中介绍过,它放置的是一个可以进行原
	子操作的整形值.
	dev_t, git_t uid_t
	处理不透明类型时的原则是:
	*不要假设该类型的长度.这些类型在某些系统中可能是32位,而在其他系统中又可能是
	64位.并且,内核开发都可以任意修改这些类型的大小
	*不要将该类型转化加其对应的C标准类型使用
	*成为一个大小不可知论者,编译时要保证在该类型实际存储空间和格式发生变化时,代
	码不受影响.

##19.3.2 指定数据类型
	内核中还有一些数据虽然无须用不透明的类型表示,但它们定义成了指定的数据类型.
	在中断控制时用到的flag参数就是个例子

##19.3.3 长度明确的类型
	作为一个程序员,你往往需要在程序中使用长度明确的数据.像操作硬件设备,进行网络
	通信和操作二进制文件时,通常都必须满足明确的内部要求.比如说,一块声卡可能用的
	是32位寄存器,一个网络包有一个16位字段,一个可以执行文件有8位的cookie.在这些
	情况下,数据对应的类型应该长度明确.
	上述这些类型只能在内核使用,不可以在用户空间出现(比如,在头文件中的某个用户可
	见结构中出现)这个限制是为了保护命名空间.不过内核对应这些不可见变量同时也定
	义了对应的用户可见的变量类型,这些类型与上面类型所不同的是增加了两个下划线前
	缀,比如,无符号32位整形对应的用户空间可见类型就是__u32.在内核中你可以任意使
	用这两个名字,但是如果是用户可见的类型,那必须使用下划线前缀的版本名,防止污染
	用户空间的命名空间.
	
##19.3.4 char型的符号问题
	c标准表示char类型可以带符号也可以不带符号.
	
	char i = -1;( 希望带符号 )

#19.4 数据对齐
	对齐就是跟数据块在内存中的位置相关的话题.如果一个变量的内存地址正好是它长度
	的整数倍,它就称作是自然对齐的.

	一些体系结构对对齐要求非常严格.通常像RISC的系统.载入未对齐的数据会导致处理
	器陷入(一种可以处理的错误).还有一些系统可以访问没有对齐的数据,只不过性能会
	下降,编写可移植性的代码要避免对齐问题,保证所有的类型都能够自然对对齐.

#19.4.1 避免对齐引发的问题
	编译器通常会通过让所有的数据自然对齐来避免引发对齐问题.
	一个数据类型长度较小,它本来是对齐的,如果你用一个指针进行类型转换,
	并且转换后类型长度较大,那么通过指针进行数据访问时就会引发对齐问题(无论如何
	某些体系结构会存在这种问题)
```c
char wolf[] ="like a wolf"
char *p = &wolf[1];
unsigned long l = *(unsigned long *)p;
```
这个例子将一个指向char型的指针当做指向unsigned long型的指针来用,这会引起问题.因
为此时会试图从一个不能被4或8整除的内存地址上载入32位或64位的unsigned long型数据.

#19.4.2 非标准类型的对齐
	前面提到了,对于标准数据类型来说,它的地址只要是其长度的整数倍就对齐了.而非标
	准C数据结构类型按照下列原则对齐:
	*对于数组,只要按照基本数据类型进行对齐就可以了,随后的所有元素自然能够对齐.
	*对于联合体,只要它包含的长度最大的数据类型能够对齐就可以了.
	*对于结构体,只要结构体中每个元素能够正确地对齐就可以了.
	结构体还要引入填补机制,这会引出下一个问题

#19.4.3 结构体填补
	为了保证结构体中每一个成员都能够自然对齐,结构体要被填补.这点确保了当前处理器
	访问结构中一个给定元素时,元素本身是对齐的,举例,下面是一个在32位机上的结构体
	struct animal_struct{
		char dog;
		unsigned long cat;
		unsigned long short pig;
		char fox;
	};

	由于该结构不能准确地满足各个成员自然对齐,所以它在内存中可不是按归原样存放的.编
	译器会在内存中创建一个类似下面给出的结构体:
	 struct animal _struct{
		 char dog;
		 u8 __pad0[3];
		 unsigned long cat;
		 unsigned short pig;
		 char fox;
		 u8 __pad2;
	 };

	填补的变更都是为了能够让数据自然对齐而加入的.第一个填充物占用了3个字节的空
	间,保证cat可以按照4字节对齐,这也自动使其他小的对象都对齐了,因为它们长度都比
	cat要小,第二个填补是为了填补struct 本身的大小.额外的这个填补使用结构体的长
	能够被4整除,这样,在由该结构体构成的数组中,每个数组项也就会自然对齐了.
	注意,在大部分32系统上,对于任何一个这样的结构体,sizeof(animal_struct)都会返回
	12,c编译器自动进行填补以保证自然对齐.
	通常你可以通常重新排列结构体中的对象来避免填充.这样既可以得到一个较小的结构
	体,又能保证无须填补它也是自然对齐的.

	struct animal_struct{
		unsigned long cat;
		unsigned long short pig;
		char dog;
		char fox;
	};
	现在这个结构体只有8字节.
	还有些时候,因为一些原因必须使用某种固定的次序---比如说,为了提高高速缓存的命
	中率.
	内核开发者需要注意结构体填补问题,特别是在整体使用时----这是指当需要通过网络
	发送它们或需要将它们写入文件的时候,因为不同体系结构之间所需要的填补也不相同
	这也是为什么c语言没有提供一个内建的结构体比较操作符的原因之一.

19.5 字节顺序
	字节顺序是批在一个字中各个字节的顺序.
	如果最高有效位所在的字节放在低字节位置上,其他字节依次放在高字节位置上,那么
	该字节顺序称作高位优先. big-endian
	如果最低有效位所在字节放在高字节位置上,其他字节依次放在低字节位置上,那么就
	称为低位优先.

	让我们考虑存放一个4字节的整形中的二进制数据,对应十进制数据1027
	00000000 00000000 00000100 00000011
	地址        big                      little
	0
	1
	2
	3


	


	
