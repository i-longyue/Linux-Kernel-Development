1.Linux内核简介
2.linux内核出发
3.进程管理
4.进程调度
5.系统调用
6.内核数据结构
7.中断和中断处理
8.中断的后半部分推进
9.同步概念
10.同步方法
11.定时器和时间管理
12.内存管理
13.VFS
14.块I/O
15.进程地址空间
16.页高速缓存
17.设备模型
18.调度


第19章  可移植性
Linux是一个可移植性非常好的操作系统,它广泛支持许多不同体系结构的计算机.
可移植性是指代码从一种体系结构移植到另外一种不同的体系结构上的方便程序.
我们都知道Linux是可以移植的,因为它已经能够在各种不同的体系结构上运行了
本章节我们将讨论如何编写可移植的代码--编写内核代码和驱动时必须时刻牢记
这个问题.

19.1 可移植操作系统
	有些操作系统在设计时把可移植性作为头等大事之一,尽可能少地涉及与机器
	相关的代码.汇编代码用得少之又少,为了支持不同类型的体系结构,界面和功
	能在定义时都尽最大可能地具有普适性和抽象性.

	与之相反,还有一种操作系统完全不考虑可移植性,它们尽最大的可能追求代码
	的性能表现.尽可能多地使用汇编代码.压根就只为在一种硬件体系结构使用.
	内核的特性都是围绕硬件提供的特性设计.因此,将其移植到其他体系结构上也
	会不适用. DOS和WIndows95.

	Linux在可移植性这个方面走的是中间路线.差不多所有的接口和核心代码都是
	独立于硬件体系结构的C语言代码.需要快速执行和底层的代码都与硬件相关并
	且是用汇编语言写成的.这种实现方式使用Linux在保持可移植性的同时兼顾对
	性能的优化.当可移植妨碍性能发挥的时候,往往性能会被优先考虑.险些之外,
	代码就一定要保证可移植性.

	一般来说,暴露在外的内核接口往往是与硬件体系结构无关的.如果函数的任何
	部分需要针对特殊的体系结构(无论是出于优化的目的还是作为一种必需的选择)
	提供支持的时候,这些部分被安置在独立的函数中,等待调用,每种被支持的体系
	结构都实现了一个与体系结构相关的函数,而且会链接到内核映像之中.

	调度程序就是就是一个好例子.调度程序的主体程序是存放在kernel/sched.c
	文件中,用C编写,与体系结构无关.可是,调度程序需要进行的一些工作,比如说
	切换处理器上下文和切换地址空间等,却不得不依靠相应的体系结构完成于是
	用C语言编译写了context_switch()用于实现进程切换,而在它的内部,则会
	调用switch_to()和switch_mm()分别完成处理器上下文和地址切换.
		而对于Linux支持的每种体系结构,它们的switch_to()和switch_mm()
	实现都各不相同.所以,当Linux需要移植到新的体系结构上的的时候,只需要
	重新编写和提供这样的函数就可以了.
		与体系结构相关的代码都存放在arch/architecture/目录中,architecture
	是Linux支持的体系结构的简称.体系结构相关的代码都存放在arch/下


#19.2 Linux移植史
	当Linuxs最初把Linux带入这个世界的时候,它只能在i386上运行.在1993年开始把
	Linux向Digital Alpha体系结构上移植了.

	当前的2.6内核把体系结构的数据进一步提高到21个
	每一种体系结构本息就可以支持不同的芯片和机型,被像支持的ARM和PowerPC等体系
	结构,它们就可以支持不同的芯片和机型.


#19.3 字长和数据类型
	能够由机器一次完成处理的数据称为字.这种我们在文档中用字符(8位)和页(许多字
	通常是4KB或8KB)来计量数据是相信的.字指位置的整数数目--

	人们通常说的某个机器多少"位"他们其实说的就是该机器的字长.
	处理器通用寄存器(general-pupose registers,GPR)的大小和它的字长一样大.
	虽然物理地址空间有时个会比字长小,但是虚拟地址空间的大小也等于字长,至少
	Linux支持的体系结构中都是这样的.此外,C语言定义的long类型总是等于机器字长
	而int类型有时会比字长小.

	字,双字以及混合
		有些操作系统和处理器不把它们的标准字长称作字,相反,出于历史原因和某种
		主观的命名习惯,它们用字来代表一些固定长度的数据类型.比如说,一些系统
		根据长度把数据划分为字节(byte,8位)字(work16),双字32和四字64.
	而实际上该机是32位的.在本书中(在Linux中一般也是这样),像我们前面所讨论的那样
	一个字就代表处理器的字长.

	对于支持的每一种体系结构,linux都要将asm/types.h中的BITS_PER_LONG定义为C类型
	的长度,也就是系统的长度.
	c语言虽然规定了变量的最小长度,但是没有规定变量具体的标准长度,它们可以根据实
	现变化国.
	牢记下述准则:
	*ANSI C标准规定,一个char长度一定是1字节.
	*尽管没有规定int类型长度是32,但是在Linux当前所支持的体系结构中,它都是32位的
	*short类型也类似,在当前所有支持的体系结构中,虽然没有明文规定,但是它都是16位
	的.
	*绝不应该假定指针和long的长度,在Linux当前支持的体系结构中,它们可以在64位和
	32位中变化.
	*由于不同体系结构的long的长度不同,决不应该假设sizeof(int) = sizeof(long)
	*类似地,也不要假设指针和int长度相等.

##19.3.1 不透明类型
	不透明数据类型隐藏了它们内部格式或结构.在C语言中,开发者们利用typedef声明一
	个类型.把它叫做不透明类型.希望其他人别去把它转化为对应的那个标准C类型.
	pid_t类型.
	另一个不透明类型的例子是atomic_t.在第10章中介绍过,它放置的是一个可以进行原
	子操作的整形值.
	dev_t, git_t uid_t
	处理不透明类型时的原则是:
	*不要假设该类型的长度.这些类型在某些系统中可能是32位,而在其他系统中又可能是
	64位.并且,内核开发都可以任意修改这些类型的大小
	*不要将该类型转化加其对应的C标准类型使用
	*成为一个大小不可知论者,编译时要保证在该类型实际存储空间和格式发生变化时,代
	码不受影响.

##19.3.2 指定数据类型
	内核中还有一些数据虽然无须用不透明的类型表示,但它们定义成了指定的数据类型.
	在中断控制时用到的flag参数就是个例子

##19.3.3 长度明确的类型
	作为一个程序员,你往往需要在程序中使用长度明确的数据.像操作硬件设备,进行网络
	通信和操作二进制文件时,通常都必须满足明确的内部要求.比如说,一块声卡可能用的
	是32位寄存器,一个网络包有一个16位字段,一个可以执行文件有8位的cookie.在这些
	情况下,数据对应的类型应该长度明确.
	上述这些类型只能在内核使用,不可以在用户空间出现(比如,在头文件中的某个用户可
	见结构中出现)这个限制是为了保护命名空间.不过内核对应这些不可见变量同时也定
	义了对应的用户可见的变量类型,这些类型与上面类型所不同的是增加了两个下划线前
	缀,比如,无符号32位整形对应的用户空间可见类型就是__u32.在内核中你可以任意使
	用这两个名字,但是如果是用户可见的类型,那必须使用下划线前缀的版本名,防止污染
	用户空间的命名空间.
	
##19.3.4 char型的符号问题
	c标准表示char类型可以带符号也可以不带符号.
	
	char i = -1;( 希望带符号 )

#19.4 数据对齐
	对齐就是跟数据块在内存中的位置相关的话题.如果一个变量的内存地址正好是它长度
	的整数倍,它就称作是自然对齐的.

	一些体系结构对对齐要求非常严格.通常像RISC的系统.载入未对齐的数据会导致处理
	器陷入(一种可以处理的错误).还有一些系统可以访问没有对齐的数据,只不过性能会
	下降,编写可移植性的代码要避免对齐问题,保证所有的类型都能够自然对对齐.

#19.4.1 避免对齐引发的问题
	编译器通常会通过让所有的数据自然对齐来避免引发对齐问题.
	一个数据类型长度较小,它本来是对齐的,如果你用一个指针进行类型转换,
	并且转换后类型长度较大,那么通过指针进行数据访问时就会引发对齐问题(无论如何
	某些体系结构会存在这种问题)
```c
char wolf[] ="like a wolf"
char *p = &wolf[1];
unsigned long l = *(unsigned long *)p;
```
这个例子将一个指向char型的指针当做指向unsigned long型的指针来用,这会引起问题.因
为此时会试图从一个不能被4或8整除的内存地址上载入32位或64位的unsigned long型数据.

#19.4.2 非标准类型的对齐
	前面提到了,对于标准数据类型来说,它的地址只要是其长度的整数倍就对齐了.而非标
	准C数据结构类型按照下列原则对齐:
	*对于数组,只要按照基本数据类型进行对齐就可以了,随后的所有元素自然能够对齐.
	*对于联合体,只要它包含的长度最大的数据类型能够对齐就可以了.
	*对于结构体,只要结构体中每个元素能够正确地对齐就可以了.
	结构体还要引入填补机制,这会引出下一个问题

#19.4.3 结构体填补
	为了保证结构体中每一个成员都能够自然对齐,结构体要被填补.这点确保了当前处理器
	访问结构中一个给定元素时,元素本身是对齐的,举例,下面是一个在32位机上的结构体
	struct animal_struct{
		char dog;
		unsigned long cat;
		unsigned long short pig;
		char fox;
	};

	由于该结构不能准确地满足各个成员自然对齐,所以它在内存中可不是按归原样存放的.编
	译器会在内存中创建一个类似下面给出的结构体:
	 struct animal _struct{
		 char dog;
		 u8 __pad0[3];
		 unsigned long cat;
		 unsigned short pig;
		 char fox;
		 u8 __pad2;
	 };

	填补的变更都是为了能够让数据自然对齐而加入的.第一个填充物占用了3个字节的空
	间,保证cat可以按照4字节对齐,这也自动使其他小的对象都对齐了,因为它们长度都比
	cat要小,第二个填补是为了填补struct 本身的大小.额外的这个填补使用结构体的长
	能够被4整除,这样,在由该结构体构成的数组中,每个数组项也就会自然对齐了.
	注意,在大部分32系统上,对于任何一个这样的结构体,sizeof(animal_struct)都会返回
	12,c编译器自动进行填补以保证自然对齐.
	通常你可以通常重新排列结构体中的对象来避免填充.这样既可以得到一个较小的结构
	体,又能保证无须填补它也是自然对齐的.

	struct animal_struct{
		unsigned long cat;
		unsigned long short pig;
		char dog;
		char fox;
	};
	现在这个结构体只有8字节.
	还有些时候,因为一些原因必须使用某种固定的次序---比如说,为了提高高速缓存的命
	中率.
	内核开发者需要注意结构体填补问题,特别是在整体使用时----这是指当需要通过网络
	发送它们或需要将它们写入文件的时候,因为不同体系结构之间所需要的填补也不相同
	这也是为什么c语言没有提供一个内建的结构体比较操作符的原因之一.

19.5 字节顺序
	字节顺序是批在一个字中各个字节的顺序.
	如果最高有效位所在的字节放在低字节位置上,其他字节依次放在高字节位置上,那么
	该字节顺序称作高位优先. big-endian
	如果最低有效位所在字节放在高字节位置上,其他字节依次放在低字节位置上,那么就
	称为低位优先.

	让我们考虑存放一个4字节的整形中的二进制数据,对应十进制数据1027
	00000000 00000000 00000100 00000011
	地址        big                      little
	0        00000000                   00000011
	1        00000000                   00000100
	2		 00000100                   00000000 
	3		 00000011                   00000000 

	最后一个例子,我们提供了如何判断给定的机器使用的是big还是little
	int x = 1;
	if (*(char *) &x == 1)
	/* litte */
	else
	/* big */

	高位优先和低位优先的历史
	对于Linux支持的每一种体系结构,相应的内核都会根据机器使用的字节在它的
	<asm/byteorder.h>中定义__BIG_ENDIAN 或__LITTLE_ENDIAN中的一个.
	这个头文件还从include/linux/byteorder/中包含一组宏命令用于完成字节

	顺序之间的相互转换.最常用的宏命令有:
	u32 __cpu_to_be32(u32);  /* 把cpu字节顺序转换为高位优先字节顺序 */
	u32 __cpu_to_le32(u32);
	u32 __be32_to_cpu(u32);
	u32 __le32_to_cpus(u32);
	这些转换能够把一种字节顺序变为另一种字节顺序.如果两种字节顺序本来就相同
	(比如,希望从本地字节顺序转化为高位优先字节顺序,而处理器本息使用的就是高
	 位优先字节顺序)

#19.6 时间
	时间测量是另一个内核概念,它随着体系结构甚至内核版本的不同而不同.绝对不要假
	定时间中断发生的频率,也就是每秒产生的jiffies数目.相反,应该使用HZ来正确计算
	是* /除以HZ.
	HZ定义在文件<asm/param.h>中
	
#19.7 页长度
	当处理用页管理的内存时,绝对不要假设页的长度.在X86-32下编程的程序员往往错误
	地认为一页的大小就是4KB.尽管x86-32机器上使用的页确实是4KB,但是其他不同的
	体系结构使用的页长度可能不同.实际上有些体系结构还同时支持多种不同长度的页.
	表19-4列表了各种体系结构使用的页长度.

	当处理用页组织管理的内存时,通过PAGE_SIZE以字节数据来表示页长度.而PAGE_SHIFT
	这个值定义了从最右端屏蔽多少位能够得到该地址对应的页的页号.举例来说,在页长
	为4KB的X86-32,PAGE_SIZE为4096而PAGE_SHIFT为12,它们都定义在<ams/page.h>中

#19.8 处理器排序
	回忆第9章和第10章,其中讨论过体系结构对指令排序问题.有些处理器严格限制指令排
	序,代码指定的所有装载或存储指令都不能被重新排序.而另外一些体系结构对排序
	要求则很弱,可以自行排序指令序列.

	在代码中,如果在对排序要求最弱的体系结构中,要保证指令执行顺序,必须使用诸如
	rmb()和wmb().


#19.9 SMP,内核抢占,高端内存
	在讨论可移植性的地方加入有关并发处理,内核抢占和高端内存的部分看起来似乎不太
	恰当.毕竟这些都不是会影响到操作系统的硬件之间有所差异的那些特性:恰恰相反,它
	们都是Linux内核本身的一些功能,硬件体系结构根本感知不到它们的存在.但是,它们
	代表的其实都是可配置的重要选项.而你的代码应该充分考虑到对它们的支持.就是说
	只有在编程时就针对SMP/内核抢占/高端内存进行了考虑,代码才会无论内存怎样配置,
	都能处安全之中,再在前面那些保证可移植性的规范下加上这几条:
	*假设你的代码会在SMP系统上运行.要正确地选择和使用锁.
	*假设你的代码会在支持内核抢占的情况下运行,要正确地选择和使用锁和内核抢占语
	句.
	*假设你的代码会运行在使用高端内存的系统上,必要时使用kmap().

#19.10 小结
	要想写出可移植性好,简洁,合适的内核代码,要注意以下两点:
	*编码尽量选取最大公因子:假定任何事情都可能发生,任何潜在的约束也都存在.
	*编码尽量选取最小公约数:不要假定给定的内核特性是可用的,仅仅需要最小的体系结
	构功能.
	编写可移植的代码需要考虑许多问题:字长,数据类型,填充,对齐,字节次序,符号,字节
	顺序,页大小以及处理器的加载/存储排序等.对于绝大多数内核开发来说.可能主要
	考虑的问题就是保证正确使用数据类型,虽然如此,说不定有朝一日,还是会有些与老的
	体系有关问题来困扰你,所以说理解移植性的重要,并且在开发内核过程中时刻注意编
	写简洁,可移植的代码是非常重要的.





	


	
